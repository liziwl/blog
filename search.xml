<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2018年Final总结</title>
    <url>/2018/12/24/2018-final/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="2018年Final总结"><a href="#2018年Final总结" class="headerlink" title="2018年Final总结"></a>2018年Final总结</h1><p>这里应有BGM：《生活倒影》- 苏云莹。伴着歌声写下这些文字，也许读者听着同样的声音，能稍稍体会到我的感受。</p>

    <div id="aplayer-JVOAulKH" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="000QQyiE1BCET1" data-server="tencent" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<p>2018年对我来说是完全地进入20+的年纪了。不说人生过了四分之一，也至少过去了五分之一，但是这对于刚告别2017的我来说，好像一切都还没准备好。</p>
<a id="more"></a>


<h2 id="冬"><a href="#冬" class="headerlink" title="冬"></a>冬</h2><p>深圳的冬天越来越反复无常，好像没有勇气下决心长大，接受规律的生活。冷空气一来，鼓舞着无从遮挡的冷风灌进衣领，裤管里。凉凉的雨粉落在手背上，好像是把最后的温暖浸润在了雨水里，接下来几天要忍受好几天的干燥，等待春天的复苏或是东南亚的海风支援。而我的一月在5门硬核（hardcore）的必修专业课中挣扎。就像这冷空气，我幸好和队友一起找到不少衣服，没有在最后凉凉。</p>
<p>假期早早地就安排了一场旅行，具体记录可以看另一篇<a href="https://blog.liziwl.cn/2018/01/30/travelogue-HAERBIN/"><strong>博文</strong></a>，这次是我这个南方人第一次感受到什么叫“凉凉”。当然，这是非常有趣的经历，第一次吃俄罗斯菜，第一次到东北，第一次吃冻梨，第一次用真正的暖气。</p>
<h2 id="春"><a href="#春" class="headerlink" title="春"></a>春</h2><p>本来冬天过了，我想这这个春天会好过一点，但是生活给我依然是硬核的感觉，毕竟是大三，决定该怎么走，联培？申请？保研？考研？工作？最后还是选择困难了。想着还是先面试看看吧，从最不情愿的方案和最容易的选择入手，准备多种备份方案。这个学期由于更换了新老师操作系统变成了最硬核（hardcore）的课。软件工程选择了腾讯的项目<a href="https://github.com/liziwl/faas" target="_blank" rel="noopener"><strong>FaaS</strong></a>。面试就伴随炎热的日子，一个比一个刺激，紧张。华为、腾讯、微众、京东、头条、哔哩哔哩、摩根士丹利、源伞、微软、英伟达，亚马逊，都通过了笔试，一些通过了面试、一些最后拿到了offer。也许是紧张或是不熟悉游戏规则，一开始的出师不利给我了很大压力，让我低落挺长时间的，不过了解到也许是本身企业文化与自身不合适，也就不再在意这件事了。面试就是这样，一方面是了解企业文化的窗口，另一方面也是一种明确目标的不断思考：企业需要什么样的人才，在社会上什么技能是有用的，哪些在课堂或者学术界的东西是真正可以用到工业界里面的。最后，我选择去英伟达，操作系统也拿了A。</p>
<h2 id="暑假"><a href="#暑假" class="headerlink" title="暑假"></a>暑假</h2><p>略，基本上是会友，实习。顺便抽空在假期里参加了本校的夏令营，拿了个保底的机会。</p>
<h2 id="秋"><a href="#秋" class="headerlink" title="秋"></a>秋</h2><p>在实习的过程中，我慢慢改变了我的想法，也许本科毕业就去工作，对我来说并不合适。一是学的越多，越觉得自己知识的有限，大部分企业追求的稳定和易维护的业务功能，所以想推进或学习最前沿的技术，基本依赖自身的兴趣驱动。在学校多待几年，保持和工业界的联系，我觉得是不错的提升自我方式。NASAC 2019 上，周明辉老师貌似也有类似的想法，在工业界跌爬滚打才能找到工业界急需解决的痛点，并进行研究。实习签订了6个月的合同，所以到12月底结束。</p>
<p>由于一直学校的事情比较忙，考牌学习只能放在周末，弄了一年终于考到了驾照，基本上都是一次过。</p>
<p>潜水也开始开始捡回，希望之后能有时间把 OW 升级成 AOW，水下真是非常有趣的世界。</p>
<p>9月达成久石让音乐会的愿望，本来夏天在香港看见宣传海报，决定要去的，错过了购票，没想到来到了深圳，就绝对不能错过了。2017年错过了张学友在深圳的演唱会，2019年的香港最终场是绝对不能错过了，搭上了末班车是超级开心的事情。</p>
<p>广东省大学生游泳锦标赛，香港摄影节，DevFast SZ，T-day，参加不少活动，具体可以看看Instagram，这里就不记录了。</p>
]]></content>
      <categories>
        <category>随感</category>
      </categories>
  </entry>
  <entry>
    <title>2019年Final总结</title>
    <url>/2019/12/24/2019-final/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="2019年Final总结"><a href="#2019年Final总结" class="headerlink" title="2019年Final总结"></a>2019年Final总结</h1><p>今年选的BGM是易烊千玺的《精彩才刚刚开始》。</p>

    <div id="aplayer-NtaYIfjK" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="001apXAh2mHRub" data-server="tencent" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<a id="more"></a>

<p><a href="https://blog.liziwl.cn/2018/12/24/2018-final/">2018年Final总结</a>回顾了到2019春节前的故事，那2019年的总结理应从2019春节前讲起。</p>
<h1 id="冬"><a href="#冬" class="headerlink" title="冬"></a>冬</h1><p>期末完没多久，既然尘埃落定、决定要继续在本校（南方科技大学）读硕士研究生，我便终止了在英伟达的实习。回学校专心搞毕业设计，毕竟，大四上（2018秋季学期）半工半读有点力不从心。毕设刚开了题，实验都还没做多少，得抓紧了。</p>
<div align=center><img data-src="/images/2019-final-1.png" style="max-width:50%" /></div>

<p>期末考完，1月15至20日去重庆玩了5天，这里应该是差一篇重庆游记，这坑看有时间能不能填上。重庆值得玩几次，吃喝性价比高，玩得也不错。去之前建议回顾《疯狂的石头》、《少年的你》、《火锅英雄》、还有一些在重庆取景的民国到抗战时期的的电影，这样去游玩更有感觉。留有遗憾的是，这次去没去 “817核工程” 因为主要太偏僻了，可能要自驾去。</p>
<h1 id="春"><a href="#春" class="headerlink" title="春"></a>春</h1><p>从重庆回来大概过了一周，2月3日除夕的前一天，又开一个说走就走的旅行，直接开车前往海口。2019年的春节在2月初，我的奶奶，用长沙话讲就是娭毑，去海口避寒去了。这次说走就走就是我的最后一次见娭毑，人生就是充满意外。这次前往海口还去了文昌，文昌的新鲜椰子真的嫩，好吃极了。</p>
<p>寒假过完，全心投入到了科研和毕业设计🎓中。</p>
<p>最后一学期我还参加了广东省大学生游泳比赛，这是我本科最后一次参加省比赛。其实决定是否参加还是挺纠结的，毕竟毕业设计的优先级更高，不能得不偿失，游泳比赛的排期和毕业设计最终答辩离得比较近，考虑了好久，也算安排上了。</p>
<div align=center><img data-src="/images/2019-final-2.png" style="max-width:50%" /></div>

<h1 id="夏"><a href="#夏" class="headerlink" title="夏"></a>夏</h1><p>暑假安排了去日本旅游，旅游的细节可以看<a href="https://mp.weixin.qq.com/s/mdAhhyxBzPabFJUQKO2rUw" target="_blank" rel="noopener">公众号-鲤池塘 的推送</a>，也可以看<a href="https://blog.liziwl.cn/2019/07/10/travelogue-JAPAN/">博客</a>发布的，两边稍有区别。之后回校做毕业设计的完善工作，投到了 <a href="https://2020.icse-conferences.org/details/icse-2020-papers/60/Collaborative-Bug-Finding-for-Android-Apps" target="_blank" rel="noopener">ICSE</a>，最后中了，之后可以去韩国，简直开心。</p>
<p>借着参加同期举办的软件测试比赛，暑期还去了北京参加 ISSTA，今年 ISSTA 升为CCF-A类会议。在北京意外的是，我表哥刚好在北京出差，竟然在同一个酒店，事先并没有联系，实在是缘分。他带我参观了字节跳动的北京总部。还有一天去和拜访隔壁班的孙力，他在 MSRA 实习，同样在中关村旁边。</p>
<p>陈天石，寒武纪创始人的讲座，看了宣传海报才知道，没想到是姚老师的学生。他来我们学校讲了很多从学术界跨界到工业界的经验，受益良多。</p>
<p>2019年是建国70周年，当然有阅兵，香港这次取消了国庆烟花，然而深圳湾却开始组织起烟花表演来。我们全家都预约到了10.1烟火的表演资格，时间长比香港跨年烟火长，看图的话就去我的Instagram。</p>
<p>其实还有一件比较沉重的事情，大概是我从北京回来没多久，娭毑走了，非常突然，只能赶回去见火化的最后一面，这对于我来说也是沉重的，是我第一次面对直系亲属的离开，慷慨光阴短暂，及时去完成该完成的事情，不要留下遗憾。</p>
<h1 id="秋"><a href="#秋" class="headerlink" title="秋"></a>秋</h1><p>秋季正式身份变成了硕士研究生，入住了新宿舍，虽说宿舍缩水没有阳台，但是至少还有独立卫浴，这点还能接受。既然转换了身份，就开始尝试不一样的东西，大约2017年我申请了志愿者证，参加过新人培训后，就没参加过正式志愿者活动。这学期参加了雪龙2号的志愿者，还有南山半马的志愿者活动，之后如果时间充裕肯定还会参加。</p>
]]></content>
      <categories>
        <category>随感</category>
      </categories>
  </entry>
  <entry>
    <title>荒木经惟-率性的老头</title>
    <url>/2017/11/28/Araki/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>也许跟名字有关系，荒木经惟保持着一片纯真，在别人认为是荒谬的照片，荒木经惟拍摄下来，并坚持认为不要压抑自己的感情，哪怕是情欲。荒木经惟最擅长拍摄的场景是人像，这就不可避免的要和拍摄对象产生关系，产生关系是需要至少三者共同参与的，摄影师，相机，拍摄对象。他认为摄影是个异化的过程，不是同化彼此，摄影的目的不是单纯的表现，而是要引出拍摄对象的特点。</p>
<p><img data-src="/images/1128_1.jpg" alt="图1"></p>
<a id="more"></a>

<p>他在《荒木经惟的写真术》中写道：“并不是拍什么都要在画面上把焦距对的准准的，焦距要对在当时的感觉或心情，当时的事物上。这才是最重要的。[1]”，如果一张照片仿佛在诉说一段故事就是有趣的，绝妙的，这样摄影就不仅仅是记录，更是表达与呈现。</p>
<p>荒木经惟大概是不喜欢洗底片吧，极少看见他描述洗底片的过程；而且他在初期因冲洗不当，保存不善，使得不少底片，之后被腐蚀，发臭。诚然，这可以看做后期自然环境参与创作的照片，虽然是无意识的，但是还是有些可惜这些底片。</p>
<p>荒木在书中写道他不喜欢完美，想每张照片都处于一种待完成的状态，让人看到的时候保留一点遐想。他的代表作大多和他的妻子阳子有关，在他妻子弥留之际一起出去玩拍摄的画册《冬之旅》，大概就是在这样的心境下完成的。在死亡来临时，不断思考摄影的意义，想把刹那间的感觉，留下来成为永恒。 </p>
<p><img data-src="/images/1128_2.jpg" alt="图2"></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 荒木经惟. (2013). <em>荒木经惟的天才写真术</em>. 中国民族摄影艺术出版社.</p>
]]></content>
      <categories>
        <category>随感</category>
      </categories>
  </entry>
  <entry>
    <title>C语言笔记-pipe的使用</title>
    <url>/2017/08/05/C-notes1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>C语言做的每个程序都有一个独立的功能，我们可以将多个程序使用管道连接到一起。原理是将前一个的stdout –&gt; 后一个的stdin，形成管道传输。</p>
<a id="more"></a>

<p>我们现在写一个程序<code>avg.c</code>，求任意个数的平均值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d,%d"</span>, &amp;s, &amp;n);</span><br><span class="line">    <span class="keyword">float</span> v = s / n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"v = %f\n"</span>, v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行编译后我们得到<code>avg</code>，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./avg</span><br><span class="line">3000,3</span><br><span class="line">v = 1000.000000</span><br></pre></td></tr></table></figure>
<p>看到程序可以正常求平均值，</p>
<p>我们再写一个统计输入的程序<code>acc.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>==i)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        count++;</span><br><span class="line">        s+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,s,count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行编译后我们得到<code>acc</code>，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./acc</span><br><span class="line">3000</span><br><span class="line">2000</span><br><span class="line">0</span><br><span class="line">5000,2</span><br></pre></td></tr></table></figure>
<p>输出数据总数<code>5000</code>和数据个数<code>2</code>。</p>
<p>我们不妨使用以上两个程序结合起来，将所有数据进行统计<code>acc</code>，之后通过管道经过<code>avg</code>计算平均值，命令可以写为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./input |  ./output</span><br></pre></td></tr></table></figure>
<p>针对这个例子这里写成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./acc | ./avg</span><br><span class="line">1000</span><br><span class="line">2000</span><br><span class="line">3000</span><br><span class="line">6700</span><br><span class="line">12000</span><br><span class="line">0</span><br><span class="line">v = 4940.000000</span><br></pre></td></tr></table></figure>
<p>输入完成我们便得到了对应的平均数。<br>以上就是通过管道，将两个小程序连接起来得到更复杂的程序的过程。</p>
]]></content>
      <categories>
        <category>编程笔记</category>
      </categories>
  </entry>
  <entry>
    <title>DM笔记-1 社交网络图挖掘</title>
    <url>/2018/06/02/DM-notes1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="图的邻居性质"><a href="#图的邻居性质" class="headerlink" title="图的邻居性质"></a>图的邻居性质</h1><a id="more"></a>

<h2 id="有向图和邻居"><a href="#有向图和邻居" class="headerlink" title="有向图和邻居"></a>有向图和邻居</h2><ol>
<li>有向图（directed graph）：是指一个包含节点集合和有向边集合的图，每条有向边写成$u → v$，其中u为有向边的源节点（source），$v$为目标节点（target）。所有的无向图都可以用有向图来表示，无向边$(u,v)$可表示为$u → v$和$v → u$。</li>
<li>路径（path）：值一个节点的序列$v0, v1, …, vk$，其中对于每个$i=1, 2, …, k-1$，都存在有向边$vi → v_{i+1}$。该路径的长度（length）为$k$，即该路径上的有向边数目。长度为k的路径上有$k+1$个节点，因此节点到自己的路径的长度为0。</li>
<li>节点$v$的$d$径内邻居（neighborhood of radius）：是指$v$在$d$步路径之内能达到的节点$u$的集合，记为$N(v,d)$。如果$V$是一个节点集合，那么$N(V,d)$是指$V$中节点在$d$步路径之内能达到的节点集合。</li>
<li>节点v的邻居描述（neighborhood profile）：是其邻居$N(v,1), N(v,2), …$的大小构成的序列$∣N(v,1)∣, ∣N(v,2)∣, …$。这里不包含$N(v,0)$，因为其大小永远为1。邻居描述可以反映哪个节点（在每个相等路径长度上，该节点的邻居大小总是大于或等于其他节点）更接近网络中心。</li>
</ol>
<h2 id="图的直径"><a href="#图的直径" class="headerlink" title="图的直径"></a>图的直径</h2><ol>
<li><p>强连通图（strongly connected）：任一节点到其他节点之间都存在路径。</p>
</li>
<li><p>直径（diameter）：满足下列条件的最小整数$d$：对于图中任何两个节点$u$和$v$，都存在一条从$u$到$v$的长度小于或等于$d$的路径。（仅对无向图、 强连通图有意义）</p>
<p> 可以通过不断增加径长计算图的邻居大小来得到图的直径，直到邻居中不能再增加节点为止。即对于每个节点$v$，找到那个使得$∣N(v,d)∣ = ∣N(v,d+1)∣$成立的最小$d$。这个$d$是从$v$到其他任意可达节点的最短路径长度的紧致上界（tight upper bound），称为$d(v)$。</p>
<p> 如果图是强连通的，则图的直径为$maxv(d(v))$。</p>
</li>
</ol>
<h2 id="传递闭包和可达性"><a href="#传递闭包和可达性" class="headerlink" title="传递闭包和可达性"></a>传递闭包和可达性</h2><ol>
<li>传递闭包（transitive closure）：是指节点对$(u,v)$的集合，其中从$u$到$v$存在一条长度大于等于0的路径，可写成$path(u,v)$。</li>
<li>节点间的可达性（reachability）：如果$path(u,v)$为真，则称$u$可到达（reach）$v$。</li>
<li>计算传递闭包的问题：就是寻找$path(u,v)$为真的所有节点对$(u,v)$。</li>
<li>可达性问题：给定图中节点$u$，寻找所有满足条件$path(u,v)$为真的$v$。</li>
</ol>
<p>参考链接：<a href="https://blog.csdn.net/liveway6/article/details/78352260" target="_blank" rel="noopener">link</a></p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
  </entry>
  <entry>
    <title>ML笔记-1</title>
    <url>/2017/08/29/ML-notes1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Week-2"><a href="#Week-2" class="headerlink" title="Week 2"></a>Week 2</h1><h2 id="Normal-Equation"><a href="#Normal-Equation" class="headerlink" title="Normal Equation"></a>Normal Equation</h2><p>知乎专栏：<a href="https://zhuanlan.zhihu.com/p/22757336" target="_blank" rel="noopener">掰开揉碎推导Normal Equation</a>，讲解了Normal Equation如何求最优解，而且还处理了存在线性相关向量的情况。</p>
<a id="more"></a>
<p>什么时候$X^TX$不可逆？</p>
<ol>
<li>Redundant features, where two features are very closely related (i.e. they are linearly dependent).</li>
<li>Too many features (e.g. $m \leq n$). In this case, delete some features or use “regularization” (to be explained in a later lesson).</li>
</ol>
<h2 id="伪逆矩阵-Pseudo-inverse"><a href="#伪逆矩阵-Pseudo-inverse" class="headerlink" title="伪逆矩阵 Pseudo-inverse"></a>伪逆矩阵 <a href="https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_pseudoinverse" target="_blank" rel="noopener">Pseudo-inverse</a></h2><p>对于矩阵$A$，如果存在一个矩阵$B$，使得$A B = B A = I$，其中$I$为与$A$, $B$同维数的单位阵，就称$A$为可逆矩阵（或者称$A$可逆），并称$B$是$A$的逆矩阵。矩阵$A$可逆的充分必要条件是$det A \neq 0$，左式隐含条件是$A$为方阵。</p>
<p>若矩阵为奇异矩阵或非方阵，则不存在逆矩阵，但可以用函数pinv(A)求其伪逆矩阵。基本语法为<code>X = pinv(A)</code>或者<code>X = pinv(A,tol)</code>,其中tol为误差 max(size(A))*eps(norm(A))。函数返回一个与$A$的转置矩阵$A^T$同型的矩阵$X$，并且满足：$A X A = A$, $X A X = X$. 此时，称矩阵$X$为矩阵$A$的伪逆，也称为广义逆矩阵。pinv(A)具有inv(A)的部分特性，但不与inv(A)完全等同。</p>
<p>若$A$的逆存在，pinv(A) = inv(A)，不过使用<code>pinv(A)</code>却会耗费时间更多。</p>
<h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix:"></a>Appendix:</h2><p>Definition in <a href="http://www.springer.com/us/book/9783319110790" target="_blank" rel="noopener"><em>Linear Algebra Done Right</em></a></p>
<h3 id="Adjoints"><a href="#Adjoints" class="headerlink" title="Adjoints"></a>Adjoints</h3><blockquote>
<p>7.2 <strong>Definition</strong> <em>adjoint,</em> $T^*$</p>
<p>Suppose $T \in \mathcal{L} (V, W)$. The <strong><em>adjoint</em></strong> of $T$ is the function $T^*$: $W \to V$ such that $$\langle Tv, w\rangle = \langle v, T^*w\rangle$$<br>for every $v \in V$ and every $w \in W$.</p>
</blockquote>
<h3 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h3><blockquote>
<p>7.18 <strong>Definition</strong> <em>normal</em></p>
<ul>
<li>An operator on an inner product space is called <strong><em>normal</em></strong> if it commutes with its adjoint.</li>
<li>In other words, $T \in \mathcal{L} (V)$ is normal if $$T T^* = T^* T$$</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>Visual Studio Code 插件 -- Settings Sync</title>
    <url>/2018/07/08/VSC-sync/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><ul>
<li><p>官方教程：</p>
<p>  <a href="http://shanalikhan.github.io/2015/12/15/Visual-Studio-Code-Sync-Settings.html" target="_blank" rel="noopener">http://shanalikhan.github.io/2015/12/15/Visual-Studio-Code-Sync-Settings.html</a></p>
</li>
<li><p>插件地址：</p>
<p>  <a href="https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync" target="_blank" rel="noopener">https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync</a></p>
</li>
</ul>
<a id="more"></a>

<h2 id="设置方式"><a href="#设置方式" class="headerlink" title="设置方式"></a>设置方式</h2><ol>
<li>在A机器上安装了Settings Sync，并做好了自己常用的插件和设置部署.</li>
<li>在github上创建能修改gist的token，保存下载，之后要用。token只有第一次有显示。</li>
<li>在A机器上，按下快捷键 <code>Shift+Alt+U</code> （上传设置），输入token，将配置上传到gist。成功上传会返回<code>gist-id</code>，如忘记复制也可直接上  <a href="https://gist.github.com/" target="_blank" rel="noopener">https://gist.github.com/</a> 查看标题为 <code>cloudSettings</code> gist-id。</li>
<li>B机器安装好 Visual Studio Code 后，首先安装Settings Sync, 并通过快捷键 <code>Shift+Alt+D</code> （下载设置），第一步提示输入 token，第二步输入<code>gist-id</code>，完成无误后，自动下载你之前在A上面上传的配置，并进行同步，最后重启Visual Studio Code生效。</li>
<li>两台机器如果要保持一致,可以在Settings Sync开启自动同步功能，之前默认是关闭的。</li>
</ol>
<h2 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h2><p>如在设置过程中有输入错误，按F1，输入 “sync reset” 清除设定，重新设置。</p>
]]></content>
      <categories>
        <category>计算机拾遗</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo 增加相册页面</title>
    <url>/2019/02/10/add-photo-page/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="项目需要的服务"><a href="#项目需要的服务" class="headerlink" title="项目需要的服务"></a>项目需要的服务</h2><ol>
<li>图床：用腾讯云Git托管 (<a href="http://dev.tencent.com/" target="_blank" rel="noopener">http://dev.tencent.com</a>) 代替，保证国内加载速度且免费，也可以都用 Github 托管。</li>
</ol>
<a id="more"></a>

<h2 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h2><ol>
<li><p>安装 npm 依赖，并更新 <code>package.json</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install exif --save</span><br><span class="line">npm install image-size --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>主题配置文件：<code>themes/next/_config.yml</code></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">@@ -119,6 +119,7 @@ menu:</span><br><span class="line">   categories: /categories/ || th</span><br><span class="line">   about: /about/ || user</span><br><span class="line">   archives: /archives/ || archive</span><br><span class="line"><span class="addition">+  Photos: /photos/ || image</span></span><br><span class="line">   #schedule: /schedule/ || calendar</span><br><span class="line">   #sitemap: /sitemap.xml || sitemap</span><br><span class="line">   #commonweal: /404/ || heartbeat</span><br><span class="line">@@ -780,7 +781,7 @@ motion:</span><br><span class="line"> # Please, choose only any one variant, do not need to install both.</span><br><span class="line"> # For install 2.x: https://github.com/theme-next/theme-next-fancybox</span><br><span class="line"> # For install 3.x: https://github.com/theme-next/theme-next-fancybox3</span><br><span class="line"><span class="deletion">-fancybox: false</span></span><br><span class="line"><span class="addition">+fancybox: true</span></span><br><span class="line"> </span><br><span class="line"> # Added switch option for separated repo in 6.0.0.</span><br><span class="line"> # Dependencies: https://github.com/theme-next/theme-next-fastclick</span><br><span class="line">@@ -788,7 +789,7 @@ fastclick: false</span><br><span class="line"> </span><br><span class="line"> # Added switch option for separated repo in 6.0.0.</span><br><span class="line"> # Dependencies: https://github.com/theme-next/theme-next-jquery-lazyload</span><br><span class="line"><span class="deletion">-lazyload: false</span></span><br><span class="line"><span class="addition">+lazyload: true</span></span><br><span class="line"> </span><br><span class="line"> # Progress bar in the top during page loading.</span><br><span class="line"> # Dependencies: https://github.com/theme-next/theme-next-pace</span><br><span class="line">@@ -851,8 +852,8 @@ vendors:</span><br><span class="line"> </span><br><span class="line">   # Internal version: 2.1.5</span><br><span class="line">   # See: http://fancyapps.com/fancybox/</span><br><span class="line"><span class="deletion">-  fancybox:</span></span><br><span class="line"><span class="deletion">-  fancybox_css:</span></span><br><span class="line"><span class="addition">+  fancybox: https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.6/jquery.fancybox.js</span></span><br><span class="line"><span class="addition">+  fancybox_css: https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.6/jquery.fancybox.css</span></span><br><span class="line"> </span><br><span class="line">   # Internal version: 1.0.6</span><br><span class="line">   # See: https://github.com/ftlabs/fastclick</span><br><span class="line">@@ -860,7 +861,7 @@ vendors:</span><br><span class="line"> </span><br><span class="line">   # Internal version: 1.9.7</span><br><span class="line">   # See: https://github.com/tuupola/jquery_lazyload</span><br><span class="line"><span class="deletion">-  lazyload:</span></span><br><span class="line"><span class="addition">+  lazyload: https://cdn.jsdelivr.net/npm/lazyload@2.0.0-beta.2/lazyload.js</span></span><br><span class="line"> </span><br><span class="line">   # Internal version: 1.2.1</span><br><span class="line">   # See: http://VelocityJS.org</span><br></pre></td></tr></table></figure>
</li>
<li><p>主题CSS配置：</p>
<ul>
<li><p><code>themes/next/source/css/_common/components/post/post-expand.styl</code></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+.posts-expand .post-body .ImageGrid-container .ImageGrid .card img &#123; margin: auto; &#125;</span></span><br><span class="line"> .posts-expand .post-body .fancybox img &#123; margin: 0 auto 25px; &#125;</span><br><span class="line"> .posts-expand .post-body img &#123; margin: 0 auto 25px; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>layout/_scripts/commons.swig</code> </p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="meta">@@ -1,9 +1,20 @@</span></span><br><span class="line"><span class="addition">+&#123;% if page.type ==='picture' %&#125;</span></span><br><span class="line"><span class="addition">+&#123;%</span></span><br><span class="line"><span class="addition">+  set js_commons = [</span></span><br><span class="line"><span class="addition">+    'src/utils.js',</span></span><br><span class="line"><span class="addition">+    'src/motion.js',</span></span><br><span class="line"><span class="addition">+    'src/minigrid.min.js',</span></span><br><span class="line"><span class="addition">+    'src/photo.js',</span></span><br><span class="line"><span class="addition">+  ]</span></span><br><span class="line"><span class="addition">+%&#125;</span></span><br><span class="line"><span class="addition">+&#123;% else %&#125;</span></span><br><span class="line"> &#123;%</span><br><span class="line">   set js_commons = [</span><br><span class="line">     'src/utils.js',</span><br><span class="line">     'src/motion.js'</span><br><span class="line">   ]</span><br><span class="line"> %&#125;</span><br><span class="line"><span class="addition">+&#123;% endif %&#125;</span></span><br><span class="line"> </span><br><span class="line"> &#123;% for common in js_commons %&#125;</span><br><span class="line">   &lt;script type="text/javascript" src="&#123;&#123; url_for(theme.js) &#125;&#125;/&#123;&#123; common &#125;&#125;?v=&#123;&#123; theme.version &#125;&#125;"&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>source/css/_custom/custom.styl</code>  </p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">@@ -1 +1,29 @@</span><br><span class="line">// Custom styles.</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+// 相册样式</span></span><br><span class="line"><span class="addition">+.ImageGrid &#123;</span></span><br><span class="line"><span class="addition">+    width: 100%;</span></span><br><span class="line"><span class="addition">+    max-width: 1040px;</span></span><br><span class="line"><span class="addition">+    margin: 0 auto;</span></span><br><span class="line"><span class="addition">+    text-align: center;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+.card &#123;</span></span><br><span class="line"><span class="addition">+    overflow: hidden;</span></span><br><span class="line"><span class="addition">+    transition: .3s ease-in-out;</span></span><br><span class="line"><span class="addition">+    border-radius: 8px;</span></span><br><span class="line"><span class="addition">+    background-color: #ddd;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+.ImageInCard &#123;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+.ImageInCard img &#123;</span></span><br><span class="line"><span class="addition">+    padding: 0 0 0 0;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+.TextInCard &#123;</span></span><br><span class="line"><span class="addition">+    line-height: 54px;</span></span><br><span class="line"><span class="addition">+    background-color: #ffffff;</span></span><br><span class="line"><span class="addition">+    font-size: 24px;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>相册页面静态化时自定义js：<code>scripts/phototool.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> ExifImage = <span class="built_in">require</span>(<span class="string">'exif'</span>).ExifImage;</span><br><span class="line"><span class="keyword">const</span> sizeOf = <span class="built_in">require</span>(<span class="string">'image-size'</span>);</span><br><span class="line"><span class="comment">//本地照片所在目录</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="string">"source/photos/images"</span>;</span><br><span class="line"><span class="comment">//要放置生成的照片信息文件目录，建议直接放在 source/photos/ 文件夹下</span></span><br><span class="line"><span class="keyword">const</span> output = <span class="string">"source/photos/photoslist.json"</span>;</span><br><span class="line"><span class="keyword">var</span> _json_out = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> itemsProcessed = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> photo_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fs.readdir(path, <span class="function"><span class="keyword">function</span> (<span class="params">err, files</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line"></span><br><span class="line">    files.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> path_file = path + <span class="string">"/"</span> + file;</span><br><span class="line">        fs.stat(path_file, <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stats.isFile()) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"%s is file"</span>, path_file);</span><br><span class="line">                <span class="keyword">new</span> ExifImage(&#123; <span class="attr">image</span>: path_file &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error, exifData</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + error.message);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">var</span> shot_time = <span class="string">""</span>;</span><br><span class="line">                        <span class="keyword">var</span> capture_time = exifData[<span class="string">'exif'</span>][<span class="string">'DateTimeOriginal'</span>];</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">typeof</span> capture_time === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                            shot_time = stats[<span class="string">'mtime'</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">var</span> tmp = capture_time.split(<span class="string">" "</span>);</span><br><span class="line">                            <span class="keyword">var</span> new_time = tmp[<span class="number">0</span>].replace(<span class="string">":"</span>, <span class="string">"-"</span>) + <span class="string">" "</span> + tmp[<span class="number">1</span>] + <span class="string">"+08:00"</span>;</span><br><span class="line">                            shot_time = <span class="keyword">new</span> <span class="built_in">Date</span>(new_time);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">var</span> y = shot_time.getFullYear();</span><br><span class="line">                        <span class="keyword">var</span> m = shot_time.getMonth() + <span class="number">1</span>;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="keyword">typeof</span> shot_time);</span><br><span class="line">                        <span class="built_in">console</span>.log(shot_time);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">var</span> dimensions = sizeOf(path_file);</span><br><span class="line">                        <span class="built_in">console</span>.log(dimensions.width, dimensions.height);</span><br><span class="line">                        <span class="keyword">var</span> this_file = &#123;&#125;;</span><br><span class="line">                        this_file[<span class="string">'w'</span>] = dimensions.width;</span><br><span class="line">                        this_file[<span class="string">'h'</span>] = dimensions.height;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">typeof</span> _json_out[y] === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                            _json_out[y] = &#123;&#125;;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">typeof</span> _json_out[y][m] === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                            _json_out[y][m] = &#123;&#125;;</span><br><span class="line">                        &#125;</span><br><span class="line">                        _json_out[y][m][file] = this_file;</span><br><span class="line"></span><br><span class="line">                        itemsProcessed++;</span><br><span class="line">                        photo_count++;</span><br><span class="line">                        <span class="comment">// console.log("+++++++++++++++++++++++++++");</span></span><br><span class="line">                        <span class="comment">// console.log(JSON.stringify(_json_out, null, 2));</span></span><br><span class="line">                        <span class="comment">// console.log(itemsProcessed);</span></span><br><span class="line">                        <span class="comment">// console.log(files.length);</span></span><br><span class="line">                        <span class="keyword">if</span> (itemsProcessed === files.length) &#123;</span><br><span class="line">                            <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(_json_out, <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">                            _json_out[<span class="string">'count'</span>] = photo_count;</span><br><span class="line">                            fs.writeFileSync(output, <span class="built_in">JSON</span>.stringify(_json_out, <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (stats.isDirectory()) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"%s is a directory"</span>, file);</span><br><span class="line">                itemsProcessed++;</span><br><span class="line">                <span class="comment">// console.log("***********************");</span></span><br><span class="line">                <span class="comment">// console.log(JSON.stringify(_json_out, null, 2));</span></span><br><span class="line">                <span class="comment">// console.log(itemsProcessed);</span></span><br><span class="line">                <span class="comment">// console.log(files.length);</span></span><br><span class="line">                <span class="keyword">if</span> (itemsProcessed === files.length) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(_json_out, <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">                    _json_out[<span class="string">'count'</span>] = photo_count;</span><br><span class="line">                    fs.writeFileSync(output, <span class="built_in">JSON</span>.stringify(_json_out, <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>相册页面加载时自定义js：<code>source/js/src/photo.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">photo = &#123;</span><br><span class="line">    page: <span class="number">1</span>,</span><br><span class="line">    <span class="comment">//offset 用于设置照片数量的上限</span></span><br><span class="line">    offset: <span class="number">100</span>,</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//这里设置的是刚才生成的 json 文件路径</span></span><br><span class="line">        $.getJSON(<span class="string">"./photoslist.json"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            that.render(that.page, data);</span><br><span class="line">            <span class="comment">//that.scroll(data);</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span> (<span class="params">page, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> begin = (page - <span class="number">1</span>) * <span class="keyword">this</span>.offset;</span><br><span class="line">        <span class="keyword">var</span> end = page * <span class="keyword">this</span>.offset;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt;= data.length) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">var</span> html, imgNameWithPattern, imgName, imageSize, imageX, imageY, li = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// console.log(data);</span></span><br><span class="line">        <span class="keyword">var</span> years = <span class="built_in">Object</span>.keys(data);</span><br><span class="line">        years.sort();</span><br><span class="line">        <span class="comment">// console.log(years);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, leni = years.length; i &lt; leni; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (years[i] !== <span class="string">"count"</span>) &#123;</span><br><span class="line">                <span class="comment">// console.log(years[i]);</span></span><br><span class="line">                <span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt; <span class="number">13</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> data[years[i]][j] !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                        <span class="comment">// 有效月</span></span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                        li += <span class="string">'&lt;h1&gt;'</span> + years[i] + <span class="string">'年&lt;em&gt;'</span> + j + <span class="string">'月&lt;/em&gt;&lt;/h1&gt;'</span> +</span><br><span class="line">                            <span class="string">'&lt;div class="ImageGrid"&gt;'</span>;</span><br><span class="line">                        images = <span class="built_in">Object</span>.keys(data[years[i]][j]);</span><br><span class="line">                        images.sort();</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>, lenk = images.length; k &lt; lenk; k++) &#123;</span><br><span class="line">                            imgNameWithPattern = images[k];</span><br><span class="line">                            imgName = imgNameWithPattern.split(<span class="string">'.'</span>)[<span class="number">0</span>];</span><br><span class="line">                            imageW = data[years[i]][j][imgNameWithPattern][<span class="string">'w'</span>];</span><br><span class="line">                            imageH = data[years[i]][j][imgNameWithPattern][<span class="string">'h'</span>];</span><br><span class="line">                            <span class="comment">//这里 380 指的是图片的宽度，可以根据自己的需要调整相册中照片的大小</span></span><br><span class="line">                            li += <span class="string">'&lt;div class="card" style="width:380px"&gt;'</span> +</span><br><span class="line">                                <span class="string">'&lt;div class="ImageInCard" style="height:'</span> + <span class="number">380</span> * imageH / imageW + <span class="string">'px"&gt;'</span> +</span><br><span class="line">                                <span class="comment">//href 和 src 的链接地址是相册照片外部链接，也可以放博客目录里</span></span><br><span class="line">                                <span class="string">'&lt;a data-fancybox="gallery" href="https://liziwl.coding.net/p/BlogPhotos/d/BlogPhotos/git/raw/master/'</span> + imgNameWithPattern + <span class="string">'" data-caption="'</span> + imgName + <span class="string">'"&gt;'</span> +</span><br><span class="line">                                <span class="string">'&lt;img src="https://liziwl.coding.net/p/BlogPhotos/d/BlogPhotos/git/raw/master/'</span> + imgNameWithPattern + <span class="string">'"/&gt;'</span> +</span><br><span class="line">                                <span class="string">'&lt;/a&gt;'</span> +</span><br><span class="line">                                <span class="string">'&lt;/div&gt;'</span> +</span><br><span class="line">                                <span class="comment">// '&lt;div class="TextInCard"&gt;' + imgName + '&lt;/div&gt;' +  //图片下显示文件名作为说明的功能</span></span><br><span class="line">                                <span class="string">'&lt;/div&gt;'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    li += <span class="string">"&lt;/div&gt;"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $(<span class="string">".ImageGrid-container"</span>).append(li);</span><br><span class="line">        $(<span class="string">".ImageGrid-container"</span>).lazyload();</span><br><span class="line">        <span class="keyword">this</span>.minigrid();</span><br><span class="line">    &#125;,</span><br><span class="line">    minigrid: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> grid = <span class="keyword">new</span> Minigrid(&#123;</span><br><span class="line">            container: <span class="string">'.ImageGrid'</span>,</span><br><span class="line">            item: <span class="string">'.card'</span>,</span><br><span class="line">            gutter: <span class="number">12</span></span><br><span class="line">        &#125;);</span><br><span class="line">        grid.mount();</span><br><span class="line">        $(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            grid.mount();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">photo.init();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>下载依赖 <code>source/js/src/minigrid.min.js</code>：<a href="https://unpkg.com/minigrid@3.1.1/dist/minigrid.min.js" target="_blank" rel="noopener">https://unpkg.com/minigrid@3.1.1/dist/minigrid.min.js</a></p>
</li>
<li><p>安装依赖 <code>fancybox3</code>：<a href="https://github.com/theme-next/theme-next-fancybox3" target="_blank" rel="noopener">https://github.com/theme-next/theme-next-fancybox3</a></p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -rf themes/next/<span class="built_in">source</span>/lib/fancybox</span><br><span class="line"><span class="built_in">cd</span> themes/next</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-fancybox3 <span class="built_in">source</span>/lib/fancybox</span><br><span class="line"><span class="built_in">cd</span> themes/next/<span class="built_in">source</span>/lib/fancybox</span><br><span class="line">rm -rf .git/</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>相册页面MD文件：<code>source/photos/index.md</code></p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 相册</span><br><span class="line">date: 2019-02-02 10:18:48</span><br><span class="line">type: "picture"</span><br><span class="line">---</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ImageGrid-container"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>相册页面展示图片路径：<code>source/photos/images</code></p>
<ul>
<li>静态化时，即运行 <code>hexo g</code> 前在此路径中放入图片</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>阿里云自定义域名的静态网站部署 OSS + CDN + HTTPS</title>
    <url>/2020/12/03/aliyun-page/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>使用以下服务域名均需备案，且最好 DNS 解析 托管在阿里云。</p>
<a id="more"></a>

<h2 id="创建子账户获取-AccessKey-ID-和-AccessKey-Secret（可选）"><a href="#创建子账户获取-AccessKey-ID-和-AccessKey-Secret（可选）" class="headerlink" title="创建子账户获取 AccessKey ID 和 AccessKey Secret（可选）"></a>创建子账户获取 AccessKey ID 和 AccessKey Secret（可选）</h2><p>这里使用了 CI 服务（GitHub Action），自动化部署需要生成子账户完成授权。<br>在 <code>RAM 访问控制</code> （ <a href="https://ram.console.aliyun.com/users" target="_blank" rel="noopener">https://ram.console.aliyun.com/users</a> ）中，申请子账户，并授予<code>编程访问</code>（启用 AccessKey ID 和 AccessKey Secret，支持通过 API 或其他开发工具访问）。</p>
<ol>
<li>申请子账户（授予<code>编程访问</code>）</li>
<li>保存 AccessKey ID 和 AccessKey Secret</li>
</ol>
<h2 id="创建对象存储对象-桶"><a href="#创建对象存储对象-桶" class="headerlink" title="创建对象存储对象-桶"></a>创建对象存储对象-桶</h2><ol>
<li>创建对象存储对象-桶（私有），并启用全球加速接入</li>
</ol>
<p>如果同样使用 GitHub Action，可以采用以下配置文件。使用<a href="https://github.com/manyuanrong/setup-ossutil" target="_blank" rel="noopener">manyuanrong/setup-ossutil</a>的插件，这里的 <code>endpoint</code> 启用了阿里云的全球加速接入，需要自行启用（建议），或者可以改用桶的地域接入域名。</p>
<p><img data-src="/images/aliyun-page/oss-1.png"></p>
<p>配置文件中的 <code>./public_artifact</code> 为静态网页编译输出目录， <code>oss://OSS_BUCKET/</code> 为对象存储桶名，需要自行修改。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">setup</span> <span class="string">aliyun</span> <span class="string">oss</span></span><br><span class="line"><span class="attr">uses:</span> <span class="string">manyuanrong/setup-ossutil@master</span></span><br><span class="line"><span class="attr">with:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">oss-accelerate.aliyuncs.com</span></span><br><span class="line">    <span class="attr">access-key-id:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.OSS_KEY_ID</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">access-key-secret:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.OSS_KEY_SECRET</span> <span class="string">&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cp</span> <span class="string">files</span> <span class="string">to</span> <span class="string">aliyun</span></span><br><span class="line"><span class="attr">run:</span> <span class="string">ossutil</span> <span class="string">cp</span> <span class="string">-rf</span> <span class="string">./public_artifact</span> <span class="string">oss://OSS_BUCKET/</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>创建桶后，需要给予之前创建的子账号管理权限（完全控制）。<br> <img data-src="/images/aliyun-page/oss-2.png"></p>
</li>
<li><p>于基础设置中启用静态页面配置<br> <img data-src="/images/aliyun-page/oss-3.png"><br> 需要配置 404 页面。Hexo 默认好像是没有 404页面的，需要自行创建。</p>
</li>
<li><p>如果部署了持续集成，每次部署会自动上传到对应的对象存储桶中。如没有使用持续集成，则需要手动上传。</p>
</li>
</ol>
<h2 id="配置-CDN"><a href="#配置-CDN" class="headerlink" title="配置 CDN"></a>配置 CDN</h2><p>其实直接将对象存储桶设置为公有读私有写一样可以访问，但是阿里云的对象存储流量稍贵，故这里套一层 CDN 降低流量费用，内网回源免流量费用，并且解决一个小 bug：首页 <code>/</code> 无法跳转到 <code>/index.html</code>。阿里云 CDN 中有 URL 重写功能能解决这个 bug。</p>
<h3 id="申请-SSL证书（启用HTTPS）"><a href="#申请-SSL证书（启用HTTPS）" class="headerlink" title="申请 SSL证书（启用HTTPS）"></a>申请 SSL证书（启用HTTPS）</h3><p>搜索 <code>证书</code>，找到 SSL证书 申请页面。阿里云也提供免费证书申请，只不过选项较多不太好找。如图所示，申请证书。按照提示验证，等待签发，无需下载证书。</p>
<p><img data-src="/images/aliyun-page/cdn%20(8).png"></p>
<h2 id="配置-CDN-细节"><a href="#配置-CDN-细节" class="headerlink" title="配置 CDN 细节"></a>配置 CDN 细节</h2><ol>
<li><p>创建 CDN 配置</p>
<ol>
<li>设定加速域名为自定义域名</li>
<li>业务类型选择图片小文件</li>
<li>源站信息选择OSS</li>
<li>端口选择443</li>
<li>加速区域选择“仅中国内地”</li>
<li>配置域名解析 CNAME 为分配的加速域名<br><img data-src="/images/aliyun-page/cdn%20(5).png"></li>
</ol>
</li>
<li><p>启用优化配置 </p>
<ol>
<li>启用 阿里云OSS私有 Bucket 回源<br><img data-src="/images/aliyun-page/cdn%20(2).png"></li>
<li>创建重写URL规则，修复访问错误<br><img data-src="/images/aliyun-page/cdn%20(3).png"></li>
<li>启用 TLS<br><img data-src="/images/aliyun-page/cdn%20(1).png"></li>
<li>启用 HTTPS，选择前面申请的SSL证书<br><img data-src="/images/aliyun-page/cdn%20(4).png"></li>
<li>启用各种压缩和优化<br><img data-src="/images/aliyun-page/cdn%20(6).png"></li>
<li>启用 IPv6<br><img data-src="/images/aliyun-page/cdn%20(7).png"></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>随感-1</title>
    <url>/2017/08/06/birthday/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="记一个十年"><a href="#记一个十年" class="headerlink" title="记一个十年"></a>记一个十年</h1><p><img data-src="/images/0806_1.png" alt="bilibili"><br>昨天20岁生日，过去了。正式踏上奔三的路程。 </p>
<p>碰到的人和事感觉像不经意播种的种子，或是不情愿栽下的树，可能是绮丽的景色。<br>回想过去的的日子话变少了，想的变多了。这也带来个问题，经常想而不去实践，希望我能尽快戒除这个拖延的习惯。</p>
]]></content>
      <categories>
        <category>随感</category>
      </categories>
  </entry>
  <entry>
    <title>C++语言笔记-1</title>
    <url>/2017/08/07/cpp-notes1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>使用书籍: <a href="https://book.douban.com/subject/25720141/" target="_blank" rel="noopener">A Tour of C++</a><br>作者: Bjarne Stroustrup (C++之父)</p>
<h1 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h1><a id="more"></a>

<ol>
<li>namespace<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
This way can make <code>std</code> visible in the current action scope. Otherwise, we need to use prefix like <code>std::</code>, which explicitly state the namespace.</li>
<li>C++ can handle override function, but if there exists ambiguity in compiling the code, the compiler will throw an error. Such like:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> d1,<span class="keyword">int</span> i1)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i2,<span class="keyword">double</span> d2)</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">int</span> result = func(<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></li>
<li>C++ sometime will do implicit conversion. Such like<br><code>int a = 7.2</code>, actually, <code>7</code> will be store in <code>a</code>.</li>
<li>C++ allow the declaration in the form<br><code>type name {parameter p1...};</code>  which seems like constructor. There is no equal between name and brace.</li>
</ol>
<h2 id="中英名词对照"><a href="#中英名词对照" class="headerlink" title="中英名词对照"></a>中英名词对照</h2><table>
<thead>
<tr>
<th>英文</th>
<th>中文</th>
</tr>
</thead>
<tbody><tr>
<td>namespace</td>
<td>命名空间</td>
</tr>
<tr>
<td>action scope</td>
<td>作用域</td>
</tr>
<tr>
<td>brace</td>
<td>花括号</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>编程笔记</category>
      </categories>
  </entry>
  <entry>
    <title>C++语言笔记-2</title>
    <url>/2017/08/09/cpp-notes2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>使用书籍: <a href="https://book.douban.com/subject/25720141/" target="_blank" rel="noopener">A Tour of C++</a><br>作者: Bjarne Stroustrup (C++之父)</p>
<h1 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h1><ol>
<li><p>C++传值的方式传实参，即是<code>type function_name(type parameter);</code>实际上是把一份副本传递给函数，因此我们修改形参（副本）不会影响主调函数的实参，并且可以将结果作为返回值使用。</p>
<p> 如果不想使用拷贝，想直接使用源数据<code>type function_name(type&amp; parameter);</code>，如果不改变源数据，还可再加上<code>const</code>前缀。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T a[n];     <span class="comment">//T[n]: n个T组成的数组</span></span><br><span class="line">T* p;       <span class="comment">//T*: 指向T的指针</span></span><br><span class="line">T&amp; r;       <span class="comment">//T&amp;: T的引用</span></span><br><span class="line"><span class="function">T <span class="title">func</span><span class="params">(A)</span></span>;  <span class="comment">//T(A): 是个返回T类型的函数，接受A类型的实参。</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>switch-case</code>只能判断常量(<code>short</code>, <code>int</code>, <code>long</code>, <code>char</code>)。</li>
<li>C++存在对象<code>new()</code>方法，但是没有自动的内存清理机制，需要手动定义清理方法<code>~class_name(){}</code>实现<code>delete()</code>功能</li>
</ol>
<a id="more"></a>
<p>4.</p>
<ul>
<li><p>值传递：</p>
<p>  形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-&gt;形参），参数的值只能传入,不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。</p>
<p>  下面这里例子，证明给入参数是个栈中拷贝，且自动销毁。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectType</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> _name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ObjectType(<span class="built_in">string</span> name) &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Creating object "</span> &lt;&lt; _name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ObjectType() &#123;</span><br><span class="line">        _name = <span class="string">"unnamed"</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Creating object "</span> &lt;&lt; _name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~ObjectType() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Destroying object "</span> &lt;&lt; _name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ObjectType x)</span> </span>&#123;</span><br><span class="line">    ObjectType y;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"in func()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectType o1;</span><br><span class="line">    ObjectType *o2p = <span class="keyword">new</span> ObjectType(<span class="string">"o2"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"in main()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    func(o1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Creating object unnamed</span><br><span class="line">Creating object o2</span><br><span class="line"><span class="keyword">in</span> main()</span><br><span class="line">Creating object unnamed</span><br><span class="line"><span class="keyword">in</span> func()</span><br><span class="line">Destroying object unnamed</span><br><span class="line">Destroying object unnamed</span><br><span class="line">Destroying object unnamed</span><br></pre></td></tr></table></figure>
<p>还有其他2种调用方式：</p>
</li>
<li><p>指针传递：</p>
<p>  形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</p>
</li>
<li><p>引用传递：</p>
<p>  形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</p>
</li>
</ul>
<h3 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h3><ul>
<li><a href="http://www.cnblogs.com/yanlingyin/archive/2011/12/07/2278961.html" target="_blank" rel="noopener">C++ 值传递、指针传递、引用传递详解</a></li>
<li><a href="http://xinklabi.iteye.com/blog/653643" target="_blank" rel="noopener">C++中引用传递与指针传递区别（进一步整理）</a></li>
</ul>
]]></content>
      <categories>
        <category>编程笔记</category>
      </categories>
  </entry>
  <entry>
    <title>C++语言笔记-3（引用传递和指针传递的区别）</title>
    <url>/2017/08/09/cpp-notes3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="引用传递和指针传递有什么区别吗？"><a href="#引用传递和指针传递有什么区别吗？" class="headerlink" title="引用传递和指针传递有什么区别吗？"></a>引用传递和指针传递有什么区别吗？</h3><a id="more"></a>
<h4 id="引用的规则："><a href="#引用的规则：" class="headerlink" title="引用的规则："></a>引用的规则：</h4><ol>
<li>引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。</li>
<li>不能有NULL引用，引用必须与合法的存储单元关联（指针则可以是NULL）。</li>
<li>一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。</li>
</ol>
<h4 id="指针传递的实质："><a href="#指针传递的实质：" class="headerlink" title="指针传递的实质："></a>指针传递的实质：</h4><ul>
<li>指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。（这里是在说实参指针本身的地址值不会变）如果理解不了大可跳过这段。</li>
</ul>
<h4 id="指针传递和引用传递一般适用于："><a href="#指针传递和引用传递一般适用于：" class="headerlink" title="指针传递和引用传递一般适用于："></a>指针传递和引用传递一般适用于：</h4><ul>
<li><p>函数内部修改参数并且希望改动影响调用者。对比指针/引用传递可以将改变由形参“传给”实参（实际上就是直接在实参的内存上修改，不像值传递将实参的值拷贝到另外的内存地址中才修改）。</p>
</li>
<li><p>另外一种用法是：当一个函数实际需要返回多个值，而只能显式返回一个值时，可以将另外需要返回的变量以指针/引用传递给函数，这样在函数内部修改并且返回后，调用者可以拿到被修改过后的变量，也相当于一个隐式的返回值传递吧。</p>
</li>
</ul>
<h3 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h3><ul>
<li><a href="http://www.cnblogs.com/yanlingyin/archive/2011/12/07/2278961.html" target="_blank" rel="noopener">C++ 值传递、指针传递、引用传递详解</a></li>
<li><a href="http://xinklabi.iteye.com/blog/653643" target="_blank" rel="noopener">C++中引用传递与指针传递区别（进一步整理）</a></li>
</ul>
]]></content>
      <categories>
        <category>编程笔记</category>
      </categories>
  </entry>
  <entry>
    <title>C++语言笔记-4（堆内存和栈内存详解）</title>
    <url>/2017/08/09/cpp-notes4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>转载：<a href="http://blog.csdn.net/abcjennifer/article/details/39780819" target="_blank" rel="noopener">堆内存和栈内存详解</a></p>
<h1 id="预备知识—程序的内存分配"><a href="#预备知识—程序的内存分配" class="headerlink" title="预备知识—程序的内存分配"></a>预备知识—程序的内存分配</h1><p>一个由C/C++编译的程序占用的内存分为以下几个部分</p>
<ol>
<li>栈区（stack）—由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈</li>
<li>堆区（heap）— 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表</li>
<li>全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。-程序结束后有系统释放</li>
<li>文字常量区—常量字符串就是放在这里的。 程序结束后由系统释放。</li>
<li>程序代码区—存放函数体的二进制代码。<a id="more"></a>

</li>
</ol>
<h1 id="例子程序"><a href="#例子程序" class="headerlink" title="例子程序"></a>例子程序</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp  </span></span><br><span class="line">inta = <span class="number">0</span>; <span class="comment">//全局初始化区  </span></span><br><span class="line"><span class="keyword">char</span>*p1; <span class="comment">//全局未初始化区  </span></span><br><span class="line">main()  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">int</span> b; <span class="comment">//栈   </span></span><br><span class="line">   <span class="keyword">char</span> s[] = <span class="string">"abc"</span>; <span class="comment">//栈   </span></span><br><span class="line">   <span class="keyword">char</span> *p2; <span class="comment">//栈    </span></span><br><span class="line">   <span class="keyword">char</span> *p3 = <span class="string">"123456"</span>; <span class="comment">//123456\0在常量区，p3在栈上。    </span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>； <span class="comment">//全局（静态）初始化区   </span></span><br><span class="line">   p1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);    </span><br><span class="line">    p2 = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>);    </span><br><span class="line">   <span class="comment">//分配得来的10和20字节的区域就在堆区, 但是注意p1、p2本身是在栈中的   </span></span><br><span class="line">   <span class="built_in">strcpy</span>(p1,<span class="string">"123456"</span>); <span class="comment">//123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆和栈的理论知识"><a href="#堆和栈的理论知识" class="headerlink" title="堆和栈的理论知识"></a>堆和栈的理论知识</h1><h2 id="申请后系统的响应"><a href="#申请后系统的响应" class="headerlink" title="申请后系统的响应"></a>申请后系统的响应</h2><ul>
<li><p>栈：<br>  只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
</li>
<li><p>堆：<br>  首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的<code>delete</code>语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>
<p>  注意这里，<code>malloc</code>分配失败会返回空指针，但new分配失败只会抛出异常,需要</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>( <span class="keyword">const</span> bad_alloc&amp; e ) &#123;  </span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="申请大小的限制"><a href="#申请大小的限制" class="headerlink" title="申请大小的限制"></a>申请大小的限制</h2></li>
<li><p>栈：<br>  在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，由编译器决定栈的大小（一般1M/2M），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p>
</li>
<li><p>堆：<br>  堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>
</li>
</ul>
<h2 id="申请效率的比较："><a href="#申请效率的比较：" class="headerlink" title="申请效率的比较："></a>申请效率的比较：</h2><ul>
<li>栈：<br>  由系统自动分配，速度较快。但程序员是无法控制的。</li>
<li>堆：<br>  由<code>new</code>分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。</li>
</ul>
<h2 id="堆和栈中的存储内容"><a href="#堆和栈中的存储内容" class="headerlink" title="堆和栈中的存储内容"></a>堆和栈中的存储内容</h2><ul>
<li>栈：<br>  在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</li>
<li>堆：<br>  一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</li>
</ul>
<h2 id="存取效率的比较"><a href="#存取效率的比较" class="headerlink" title="存取效率的比较"></a>存取效率的比较</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">chars[] = <span class="string">"abc"</span>; <span class="comment">//栈   </span></span><br><span class="line"><span class="keyword">char</span>*p3 = <span class="string">"123456"</span>; <span class="comment">//123456\0在常量区，p3在栈上。</span></span><br></pre></td></tr></table></figure>
<p>abc是在运行时刻赋值的；而123456是在编译时就确定的；但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。</p>
<h2 id="小心内存泄漏"><a href="#小心内存泄漏" class="headerlink" title="小心内存泄漏"></a>小心内存泄漏</h2><p>在堆上分配内存很容易造成内存泄漏，这是C/C++的最大的“克星”，如果你的程序要稳定，那么就不要出现MemoryLeak。所以，我还是要在这里千叮咛万嘱付，在使用malloc系统函数（包括<code>calloc</code>，<code>realloc</code>）时千万要小心。</p>
<p>记得有一个UNIX上的服务应用程序，大约有几百的C文件编译而成，运行测试良好，等使用时，每隔三个月系统就是down一次，搞得许多人焦头烂额，查不出问题所在。只好，每隔两个月人工手动重启系统一次。出现这种问题就是MemeryLeak在做怪了，在C/C++中这种问题总是会发生，所以你一定要小心。</p>
<h2 id="对于malloc和free的操作有以下规则："><a href="#对于malloc和free的操作有以下规则：" class="headerlink" title="对于malloc和free的操作有以下规则："></a>对于<code>malloc</code>和<code>free</code>的操作有以下规则：</h2><ol>
<li>配对使用，有一个malloc，就应该有一个free。（C++中对应为new和delete）</li>
<li>尽量在同一层上使用，不要malloc在函数中，而free在函数外。最好在同一调用层上使用这两个函数。</li>
<li>malloc分配的内存一定要初始化。free后的指针一定要设置为NULL。</li>
</ol>
<h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>虽然现在的操作系统（如：UNIX和Win2k/NT）都有进程内存跟踪机制，也就是如果你有没有释放的内存，操作系统会帮你释放。但操作系统依然不会释放你程序中所有产生了MemoryLeak的内存，所以，最好还是你自己来做这个工作。（有的时候不知不觉就出现MemoryLeak了，而且在几百万行的代码中找无异于海底捞针，Rational有一个工具叫Purify，可能很好的帮你检查程序中的MemoryLeak）</p>
]]></content>
      <categories>
        <category>编程笔记</category>
      </categories>
  </entry>
  <entry>
    <title>C++语言笔记-5</title>
    <url>/2017/08/22/cpp-notes5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h1><ol>
<li><p><code>struct</code>成员属性的访问方式：<br>一种是通过名字或引用，另一种是通过指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Vector c, Vector&amp; rv, Vector* pv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i1 = v.sz;</span><br><span class="line">    <span class="keyword">int</span> i2 = rv.sz;</span><br><span class="line">    <span class="keyword">int</span> i4 = pv-&gt;sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明函数时，显式告知编译器将进行重写函数(override)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">type <span class="title">func_name</span><span class="params">(type parameters)</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>
<p>编译器会检查父类是否存在该函数。</p>
</li>
<li><p>可重写构造函数或者运算符实现“移动”功能，减少多次声明临时变量造成的内存使用。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>编程笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu 16.04 CUDA 安装</title>
    <url>/2018/08/04/cuda/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>Ubuntu 16.04 LTS</li>
<li>CUDA 9.2 <a href="https://developer.nvidia.com/cuda-toolkit" target="_blank" rel="noopener">官网</a> 选择 runfile(local)版本</li>
<li>Anaconda Python3.6 <a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">官网</a></li>
</ul>
<a id="more"></a>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h2><p>要点：</p>
<ul>
<li>禁用图形界面服务</li>
<li>BIOS 调整至显卡显示，否则会出现循环登陆错误</li>
<li>不需要另外安装驱动，直接使用CUDA安装包内驱动，否则可能不兼容。</li>
</ul>
<ol>
<li><p>禁用图形服务</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/lightdm stop   <span class="comment"># 禁用图形服务</span></span><br><span class="line">sudo rm ~/.Xauthority           <span class="comment"># 删除X11 配置文件</span></span><br></pre></td></tr></table></figure>

<p> 然后，切换至命令行模式操作。</p>
</li>
</ol>
<ol start="2">
<li><p>安装一些必要依赖</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装CUDA</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sh cuda_9.2.148_396.37_linux.run</span><br></pre></td></tr></table></figure>

<p> 安装过程中所有提示选择YES，包括安装 NVIDIA 驱动。路径默认即可。</p>
</li>
<li><p>重启图形服务</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/lightdm restart</span><br><span class="line">sudo reboot <span class="comment">#重启系统，使得设置生效。</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h2><ol>
<li><p>运行安装脚本</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sh Anaconda3-5.2.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置用户权限，否则无法 pip 安装包</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chown -R xxx:yyy anaconda3/    <span class="comment"># 将 xxx，yyy更换为用户名和组名，一般情况xxx和yyy相同。</span></span><br><span class="line">pip install msgpack</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="安装-Pytorch"><a href="#安装-Pytorch" class="headerlink" title="安装 Pytorch"></a>安装 Pytorch</h2><ul>
<li>可以创建新的个人虚拟环境，然后安装 Pytorch。或者直接在 conda 的 base 环境安装，这里省去自定义环境环节。</li>
</ul>
<ol>
<li><p>按照官网输入命令，输入时替换 pip3 为 pip。因为 conda 默认的 pip 就是 pip3。</p>
</li>
<li><p>测试环境，输入 <code>python</code> 打开交互命令行。输入以下命令，不报错就安装正确。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch                <span class="comment"># 不报错，torch 安装正确</span></span><br><span class="line">torch.cuda.is_available()   </span><br><span class="line"><span class="comment"># Ture</span></span><br><span class="line"><span class="comment"># 返回以上字段，CUDA 和 torch 安装兼容，后面可以使用 GPU 进行学习。</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>数据库-1（primary key与unique的区别）</title>
    <url>/2017/09/22/database-notes1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>定义了<strong>UNIQUE</strong>约束的字段中不能包含重复值，可以为一个或多个字段定义<strong>UNIQUE</strong>约束。因此，<strong>UNIQUE</strong>即可以在字段级也可以在表级定义， 在 <strong>UNIQUED</strong>约束的字段上可以包含空值。ORACLE自动会为具有<strong>PRIMARY KEY</strong>约束的字段(主码字段)建立一个唯一索引和一个NOT NULL约束,定义PRIMARY KEY约束时可以为它的索引；</p>
<a id="more"></a>
<p><strong>UNIQUED</strong>可空，可以在一个表里的一个或多个字段定义；<strong>PRIMARY KEY</strong>不可空不可重复，在一个表里可以定义联合主键；</p>
<p>简单的说，primary key = unique +  not null</p>
<p>unique 就是唯一，当你需要限定你的某个表字段每个值都唯一,没有重复值时使用。比如说,如果你有一个person 表，并且表中有个身份证的column，那么你就可以指定该字段为unique。 从技术的角度来看，Primary Key和Unique Key有很多相似之处。但还是有以下区别：</p>
<ol>
<li>作为Primary Key的域/域组不能为null，而Unique Key可以。</li>
<li>在一个表中只能有一个Primary Key，而多个Unique Key可以同时存在。<br>更大的区别在逻辑设计上。Primary Key一般在逻辑设计中用作记录标识，这也是设置Primary Key的本来用意，而Unique Key只是为了保证域/域组的唯一性。</li>
</ol>
<p>oracle的constraint中有两种约束，都是对列的唯一性限制――unique与primary key，但其中是有区别的：</p>
<ol>
<li>unique key要求列唯一，但不包括null字段，也就是约束的列可以为空且仅要求列中的值除null之外不重复即可；</li>
<li>primary key也要求列唯一，同时又限制字段的值不能为null，相当于Primary Key=unique + not null。</li>
</ol>
<p>创建一个primary key和unique key都会相应的创建一个unique index。</p>
<p>primary key的语法：<code>alter table table name add constraint key name primary key( columns);</code></p>
<p>unique key的语法：<code>alter table table name add constraint key name unique( columns);</code></p>
<p>一个表只能有一个主键，但是可以有好多个UNIQUE，而且UNIQUE可以为NULL值，如员工的电话号码一般就用UNIQUE，因为电话号码肯定是唯一的，但是有的员工可能没有电话。</p>
<p>主键肯定是唯一的，但唯一的不一定是主键；不要把UNIQUE索引和UNIQUE约束混为一谈</p>
<ol>
<li>primary key = unique + not null</li>
<li>唯一约束和主键一样都是约束的范畴，而且都可以作为外键的参考，不同的是，一张表只能有一个主键</li>
<li>主键和唯一约束的创建需要依靠索引，如果在创建主键或唯一约束的时候没有已经建好的索引可以使用的话，Oracle会自动建立一个唯一的索引。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>数据库-2</title>
    <url>/2017/09/24/database-notes2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="SQL-第一范式、第二范式、第三范式、BCNF"><a href="#SQL-第一范式、第二范式、第三范式、BCNF" class="headerlink" title="SQL 第一范式、第二范式、第三范式、BCNF"></a>SQL 第一范式、第二范式、第三范式、BCNF</h1><a id="more"></a>
<h2 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式 1NF"></a>第一范式 1NF</h2><p>要求：每一个分量必须是不可分的数据项。</p>
<p>特点：</p>
<ol>
<li>有主键，且主键不能为空。</li>
<li>字段不能再分。</li>
</ol>
<p>示例：（以下例子 不满足 第一范式）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*学号      年龄        信息*&#x2F;</span><br><span class="line">  Sno       Sage        Sinfo</span><br><span class="line">  1001      19          陕西省西安市，电话：10086</span><br><span class="line">  1001      20          陕西，宝鸡</span><br></pre></td></tr></table></figure>
<p>主键：Sno</p>
<p>不满足原因：</p>
<ol>
<li>主键重复。</li>
<li>Sinfo字段可以再分。</li>
</ol>
<h2 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式 2NF"></a>第二范式 2NF</h2><p>要求：在范式一的基础上，且每一个非主属性完全函数依赖于码。</p>
<p>特点：</p>
<ol>
<li>满足第一范式。</li>
<li>表中的每一个非主属性，必须完全依赖于本表码。</li>
<li>只有当一个表中，主码由两个或以上的属性组成的时候，才会出现不符合第二范式的情况。</li>
</ol>
<p>示例：（以下例子 不符合 第二范式）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*学号    课程号     得分    课程名*&#x2F;</span><br><span class="line">  Sno      Cno      Score    Sname</span><br><span class="line">  1001     001       99      数据库</span><br></pre></td></tr></table></figure>
<p>主键： Sno,Cno</p>
<p>不满足原因：Sname不完全依赖于码，课程名部分依赖于码Cno。</p>
<h2 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式 3NF"></a>第三范式 3NF</h2><p>要求：在满足第二范式的基础上，且每一个非主属性既不部分依赖于码也不传递依赖于码。</p>
<p>特点：</p>
<ol>
<li>满足第二范式。</li>
<li>非主属性不能传递依赖于码。</li>
</ol>
<p>示例：（以下例子 不符合 第三范式）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*学号     系别     系主任*&#x2F;</span><br><span class="line">  Sno     Sdept     Shead</span><br><span class="line">  1001   计算机系    张三</span><br></pre></td></tr></table></figure>
<p>主键：Sno</p>
<p>不满足原因：Shead传递依赖于码，Sno-&gt;Sdept-&gt;Shead，可得Sno-&gt;Shead。</p>
<h2 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h2><p>要求：在满足第三范式的基础上，且不允许主键的一部分被另一部分或其它部分决定。</p>
<p>特定：</p>
<ol>
<li>满足第三范式。</li>
<li>所有非主属性对每一个码都是完全函数依赖。</li>
<li>所有的主属性对每一个不包含它的码，也是完全函数依赖。</li>
<li>没有任何属性完全函数依赖于飞码的任何一组属性。</li>
</ol>
<p>示例：（以下例子 不符合 第BCNF范式）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*学生       老师        课程*&#x2F;</span><br><span class="line">  Stu      Teacher      Course</span><br><span class="line">  张三       李开复       数据库</span><br></pre></td></tr></table></figure>
<p>假设：每个老师只教一门课。</p>
<p>候选码：</p>
<ul>
<li>(Stu,Teacher)-&gt;Course</li>
<li>(Stu,Course)-&gt;Teacher<br>这两个码由两个属性组成，而且它们是相互交叉的，所以不存在传递依赖，所以为3NF。</li>
</ul>
<p>但是由于：Teacher-&gt;Course，（主键的一部分被另一部分决定），所以不符合BCNF。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a href="https://www.zhihu.com/question/24696366/answer/29189700" target="_blank" rel="noopener">知乎回答-刘慰：解释一下关系数据库的第一第二第三范式？</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>FaaS</title>
    <url>/2018/06/04/faas/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="FaaS-DEMO页面"><a href="#FaaS-DEMO页面" class="headerlink" title="FaaS DEMO页面"></a>FaaS DEMO页面</h1><p><strong>展示页面已下线</strong></p>
<p><a href="http://self.sustech.pub/faas/simple.html" target="_blank" rel="noopener">http://self.sustech.pub/faas/simple.html</a></p>
<h1 id="项目仓库"><a href="#项目仓库" class="headerlink" title="项目仓库"></a>项目仓库</h1><p><a href="https://github.com/liziwl/faas" target="_blank" rel="noopener">https://github.com/liziwl/faas</a></p>
]]></content>
      <categories>
        <category>链接</category>
      </categories>
  </entry>
  <entry>
    <title>解决gazebo启动错误</title>
    <url>/2018/03/19/fix_gazebo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>参考链接: <a href="https://answers.ros.org/question/199401/problem-with-indigo-and-gazebo-22/" target="_blank" rel="noopener">link</a></p>
<a id="more"></a>

<h1 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ gazebo</span><br><span class="line">Gazebo multi-robot simulator, version 2.2.3</span><br><span class="line">Copyright (C) 2012-2014 Open Source Robotics Foundation.</span><br><span class="line">Released under the Apache 2 License.</span><br><span class="line">http://gazebosim.org</span><br><span class="line"></span><br><span class="line">Msg Waiting <span class="keyword">for</span> master</span><br><span class="line">Gazebo multi-robot simulator, version 2.2.3</span><br><span class="line">Copyright (C) 2012-2014 Open Source Robotics Foundation.</span><br><span class="line">Released under the Apache 2 License.</span><br><span class="line">http://gazebosim.org</span><br><span class="line"></span><br><span class="line">Msg Waiting <span class="keyword">for</span> master</span><br><span class="line">Msg Connected to gazebo master @ http://127.0.0.1:11345</span><br><span class="line">Msg Publicized address: 192.168.1.152</span><br><span class="line">Msg Connected to gazebo master @ http://127.0.0.1:11345</span><br><span class="line">Msg Publicized address: 192.168.1.152</span><br><span class="line">Warning [ModelDatabase.cc:334] Getting models from[http://gazebosim.org/models/]. This may take a few seconds.</span><br><span class="line">Warning [gazebo.cc:215] Waited 1seconds <span class="keyword">for</span> namespaces.</span><br><span class="line">Warning [gazebo.cc:215] Waited 1seconds <span class="keyword">for</span> namespaces.</span><br><span class="line">Warning [gazebo.cc:215] Waited 1seconds <span class="keyword">for</span> namespaces.</span><br><span class="line">Warning [gazebo.cc:215] Waited 1seconds <span class="keyword">for</span> namespaces.</span><br><span class="line">Warning [gazebo.cc:215] Waited 1seconds <span class="keyword">for</span> namespaces.</span><br><span class="line">Warning [gazebo.cc:215] Waited 1seconds <span class="keyword">for</span> namespaces.</span><br><span class="line">Warning [gazebo.cc:215] Waited 1seconds <span class="keyword">for</span> namespaces.</span><br><span class="line">Warning [gazebo.cc:215] Waited 1seconds <span class="keyword">for</span> namespaces.</span><br><span class="line">Warning [gazebo.cc:215] Waited 1seconds <span class="keyword">for</span> namespaces.</span><br><span class="line">Warning [gazebo.cc:215] Waited 1seconds <span class="keyword">for</span> namespaces.</span><br><span class="line">Error [gazebo.cc:220] Waited 11 seconds <span class="keyword">for</span> namespaces. Giving up.</span><br></pre></td></tr></table></figure>

<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>Gazebo try to collect models from <a href="http://gazebosim.org/models" target="_blank" rel="noopener">http://gazebosim.org/models</a> but there is something wrong.</p>
<p>OR the folder <code>~/.gazebo/models</code> does not exist and Gazebo simulator can not start. </p>
<h1 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h1><p>运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r -R &quot;index\.html*&quot; &quot;http:&#x2F;&#x2F;models.gazebosim.org&quot; --reject&#x3D;tar.gz</span><br></pre></td></tr></table></figure>
<p>Got all models from gazebosim and copy them into <code>~/.gazebo/models</code> folder and everything will be ok.</p>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
  </entry>
  <entry>
    <title>git-代码冲突常见解决方法</title>
    <url>/2017/10/01/git-notes1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>如果系统中有一些配置文件在服务器上做了配置修改，然后后续开发又新添加一些配置项的时候,<br>在发布这个配置文件的时候，会发生代码冲突：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: Your local changes to the following files would be overwritten by merge:</span><br><span class="line">        protected&#x2F;config&#x2F;main.php</span><br><span class="line">Please, commit your changes or stash them before you can merge.</span><br></pre></td></tr></table></figure>

<p>如果希望保留生产服务器上所做的改动，仅仅并入新配置项，处理方法如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash</span><br><span class="line">git pull</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>
<p>然后可以使用<code>git diff -w [文件名]</code> 来确认代码自动合并的情况。</p>
<p>解决文件中冲突的的部分：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; Updated upstream</span><br><span class="line">Code block A</span><br><span class="line">=======</span><br><span class="line">Code block B</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; Stashed changes</span><br></pre></td></tr></table></figure>
<p>其中<code>Updated upstream</code>和<code>=======</code>之间的内容就是pull下来的内容，<code>=======</code>和<code>Stashed changes</code>之间的内容就是本地修改的内容。碰到这种情况，git也不知道哪行内容是需要的，所以要自行确定需要的内容。</p>
<p>解决完成之后，就可以正常的提交了。</p>
<p>反过来，如果希望用代码库中的文件完全覆盖本地工作版本。方法如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p>其中git reset是针对版本,如果想针对文件回退本地修改,使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout HEAD file/to/restore</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>git-解决fork仓库和源仓库同步问题</title>
    <url>/2018/05/02/git-notes2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>项目 fetch 到本地，通过命令行的方式 merge<br>提示：跟上游仓库同步代码之前，必须配置过 remote，指向<a href="https://help.github.com/articles/configuring-a-remote-for-a-fork/" target="_blank" rel="noopener">上游仓库</a>。</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</span><br></pre></td></tr></table></figure>
<h2 id="合并仓库"><a href="#合并仓库" class="headerlink" title="合并仓库"></a>合并仓库</h2><ol>
<li><p>打开命令行工具</p>
</li>
<li><p>切换当前工作路径至你的本地工程</p>
</li>
<li><p>从上游仓库获取(fetch)到分支，及相关的提交信息，它们将被保存在本地的 <code>upstream/master</code> 分支 ```bash<br>git fetch upstream</p>
<h1 id="remote-Counting-objects-75-done"><a href="#remote-Counting-objects-75-done" class="headerlink" title="remote: Counting objects: 75, done."></a>remote: Counting objects: 75, done.</h1><h1 id="remote-Compressing-objects-100-53-53-done"><a href="#remote-Compressing-objects-100-53-53-done" class="headerlink" title="remote: Compressing objects: 100% (53/53), done."></a>remote: Compressing objects: 100% (53/53), done.</h1><h1 id="remote-Total-62-delta-27-reused-44-delta-9"><a href="#remote-Total-62-delta-27-reused-44-delta-9" class="headerlink" title="remote: Total 62 (delta 27), reused 44 (delta 9)"></a>remote: Total 62 (delta 27), reused 44 (delta 9)</h1><h1 id="Unpacking-objects-100-62-62-done"><a href="#Unpacking-objects-100-62-62-done" class="headerlink" title="Unpacking objects: 100% (62/62), done."></a>Unpacking objects: 100% (62/62), done.</h1><h1 id="From-https-github-com-ORIGINAL-OWNER-ORIGINAL-REPOSITORY"><a href="#From-https-github-com-ORIGINAL-OWNER-ORIGINAL-REPOSITORY" class="headerlink" title="From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY"></a>From <a href="https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY" target="_blank" rel="noopener">https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY</a></h1><h1 id="new-branch-master-gt-upstream-master"><a href="#new-branch-master-gt-upstream-master" class="headerlink" title="* [new branch]      master     -&gt; upstream/master"></a>* [new branch]      master     -&gt; upstream/master</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4. 切换到本地的 &#96;master&#96; 分支 &#96;&#96;&#96;bash</span><br><span class="line">git checkout master</span><br><span class="line"># Switched to branch &#39;master&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把 <code>upstream/master</code> 分支合并到本地的 <code>master</code> 分支，本地的 <code>master</code> 分支便跟上游仓库保持同步了，并且没有丢失你本地的修改。 ```bash<br>git merge upstream/master</p>
<h1 id="Updating-a422352-5fdff0f"><a href="#Updating-a422352-5fdff0f" class="headerlink" title="Updating a422352..5fdff0f"></a>Updating a422352..5fdff0f</h1><h1 id="Fast-forward"><a href="#Fast-forward" class="headerlink" title="Fast-forward"></a>Fast-forward</h1><h1 id="README-9-——"><a href="#README-9-——" class="headerlink" title="README                    |    9 ——-"></a>README                    |    9 ——-</h1><h1 id="README-md-7"><a href="#README-md-7" class="headerlink" title="README.md                 |    7 ++++++"></a>README.md                 |    7 ++++++</h1><h1 id="2-files-changed-7-insertions-9-deletions"><a href="#2-files-changed-7-insertions-9-deletions" class="headerlink" title="2 files changed, 7 insertions(+), 9 deletions(-)"></a>2 files changed, 7 insertions(+), 9 deletions(-)</h1><h1 id="delete-mode-100644-README"><a href="#delete-mode-100644-README" class="headerlink" title="delete mode 100644 README"></a>delete mode 100644 README</h1><h1 id="create-mode-100644-README-md"><a href="#create-mode-100644-README-md" class="headerlink" title="create mode 100644 README.md"></a>create mode 100644 README.md</h1><pre><code>
</code></pre>
</li>
</ol>
<p>提示：同步后的代码仅仅是保存在本地仓库，记得 <code>push</code> 到 Github 哟。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>git-解决 Windows 下Git SSH 代理设置</title>
    <url>/2020/04/06/git-notes3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>不知道为啥，我电脑上的 HTTP Git token 过段时间就过期，又要重新授权，就很烦。想到 SSH 没有这个但是速度比较慢，HTTP 设置很简单。SSH稍微复杂一些今天就介绍一下。</p>
<a id="more"></a>

<h2 id="http-的代理设置-Windows-amp-Unix"><a href="#http-的代理设置-Windows-amp-Unix" class="headerlink" title="http 的代理设置 Windows &amp; Unix"></a>http 的代理设置 Windows &amp; Unix</h2><p>1080 为 代理服务器 (127.0.0.1) 的端口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置 -- 代理服务器 为 http 协议</span></span><br><span class="line">git config --global http.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 -- 代理服务器 为 socks5 协议</span></span><br><span class="line">git config --global http.proxy <span class="string">'socks5://127.0.0.1:1080'</span></span><br><span class="line">git config --global https.proxy <span class="string">'socks5://127.0.0.1:1080'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消设置</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>

<h2 id="SSH-的代理设置"><a href="#SSH-的代理设置" class="headerlink" title="SSH 的代理设置"></a>SSH 的代理设置</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ol>
<li>进入自己的用户目录 <code>C:\Users\YOUR_NAME\.ssh</code></li>
<li>新建或者打开文件 <code>config</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  User git</span><br><span class="line">  Port 22</span><br><span class="line">  Hostname github.com</span><br><span class="line">  IdentityFile &quot;C:\Users\YOUR_NAME\.ssh\id_ed25519&quot;</span><br><span class="line">  TCPKeepAlive yes</span><br><span class="line">  ProxyCommand &quot;C:\Program Files\Git\mingw64\bin\connect.exe&quot; -S 127.0.0.1:1080 %h %p</span><br><span class="line"></span><br><span class="line">Host ssh.github.com</span><br><span class="line">  User git</span><br><span class="line">  Port 443</span><br><span class="line">  Hostname ssh.github.com</span><br><span class="line">  IdentityFile &quot;C:\Users\YOUR_NAME\.ssh\id_ed25519&quot;</span><br><span class="line">  TCPKeepAlive yes</span><br><span class="line">  ProxyCommand &quot;C:\Program Files\Git\mingw64\bin\connect.exe&quot; -S 127.0.0.1:1080 %h %p</span><br></pre></td></tr></table></figure>

<p><code>IdentityFile</code> 就是你的 SSH 私钥文件名</p>
<p><code>ProxyCommand</code> 是代理命令，后面是 Git 自带的 <code>connect</code> 注意路径和实际一致。 <code>-S</code> 参数意味着 使用 sock 协议代理，如果使用 http 协议代理使用 <code>-H</code> 参数。</p>
<h3 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix</h3><p>稍有不同，因为我用的是 Manjaro 没有自带 netcat 也就是 nc。特别注意这里使用的是 <strong>OpenBSD</strong> 的 netcat，不是 GNU 的 netcat。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    Port 22</span><br><span class="line">    Hostname github.com</span><br><span class="line">    IdentityFile &quot;&#x2F;home&#x2F;YOUR_NAME&#x2F;.ssh&#x2F;id_ed25519&quot;</span><br><span class="line">    TCPKeepAlive yes</span><br><span class="line">    ProxyCommand nc -X connect -x 127.0.0.1:7890 %h %p  # HTTP proxy</span><br><span class="line">    ProxyCommand nc -x 127.0.0.1:7891 %h %p  # sock proxy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Host ssh.github.com</span><br><span class="line">    User git</span><br><span class="line">    Port 443</span><br><span class="line">    Hostname ssh.github.com</span><br><span class="line">    IdentityFile &quot;&#x2F;home&#x2F;YOUR_NAME&#x2F;.ssh&#x2F;id_ed25519&quot;</span><br><span class="line">    TCPKeepAlive yes</span><br><span class="line">    ProxyCommand nc -X connect -x 127.0.0.1:7890 %h %p  # HTTP proxy</span><br><span class="line">    ProxyCommand nc -x 127.0.0.1:7891 %h %p  # sock proxy</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu 安装 glfw 和 OpenGL</title>
    <url>/2018/07/29/glfw/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Ubuntu 安装 glfw 和 OpenGL</p>
<a id="more"></a>

<h1 id="安装-glfw"><a href="#安装-glfw" class="headerlink" title="安装 glfw"></a>安装 glfw</h1><h2 id="下载源码，解压"><a href="#下载源码，解压" class="headerlink" title="下载源码，解压"></a>下载源码，解压</h2><p>在<a href="www.glfw.org">官网</a>下载最新源码 <code>glfw-x.x.x.zip</code></p>
<p>解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip glfw-x.x.x.zip</span><br></pre></td></tr></table></figure>

<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><ol>
<li><p>安装依赖库</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install build-essential cmake</span><br></pre></td></tr></table></figure></li>
<li><p>进入 glfw-x.x.x 目录，建立glfw-build子目录</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir glfw-build</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>进入glfw-build，使用cmake命令生成Makefile</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cmake ../</span><br></pre></td></tr></table></figure>
</li>
<li><p>make &amp;&amp; make install</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试运行</p>
<p> 新建文件 <code>test.c</code></p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GLFWwindow* window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the library */</span></span><br><span class="line">    <span class="keyword">if</span> (!glfwInit())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a windowed mode window and its OpenGL context */</span></span><br><span class="line">    window = glfwCreateWindow(<span class="number">640</span>, <span class="number">480</span>, <span class="string">"Hello World"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window)</span><br><span class="line">    &#123;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make the window's context current */</span></span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loop until the user closes the window */</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Render here */</span></span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Swap front and back buffers */</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Poll for and process events */</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译测试</p>
<ul>
<li><p>查看链接命令，每个输出结果连接起来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkg-config --static --libs glfw3</span><br><span class="line"><span class="comment"># -L/usr/local/lib -lglfw3 -lrt -lm -ldl -lXrandr -lXinerama -lXxf86vm -lXext -lXcursor -lXrender -lXfixes -lX11 -lpthread -lxcb -lXau -lXdmcp</span></span><br><span class="line">pkg-config --libs gl</span><br><span class="line"><span class="comment"># -lGL</span></span><br><span class="line"><span class="comment"># 另外还需链接：</span></span><br><span class="line"><span class="comment"># -lX11 -lm -lrt -ldl</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>组成编译语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test.c -L/usr/<span class="built_in">local</span>/lib -lglfw3 -lrt -lm -ldl -lXrandr -lXinerama -lXxf86vm -lXext -lXcursor -lXrender -lXfixes -lX11 -lpthread -lxcb -lXau -lXdmcp -lGL -lX11 -lm -lrt -ldl</span><br></pre></td></tr></table></figure>
<h1 id="安装-OpenGL"><a href="#安装-OpenGL" class="headerlink" title="安装 OpenGL"></a>安装 OpenGL</h1></li>
</ul>
</li>
<li><p>一行全部安装：编译环境, OpenGLLibrary, OpenGLUtilities, OpenGLUtility Toolkit</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential libgl1-mesa-dev libglu1-mesa-dev freeglut3-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时openGL安装完毕,以下为测试阶段</p>
<p> 新建文件 <code>opengl.c</code></p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    glClearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glOrtho(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">-5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">15</span>);</span><br><span class="line">    glMatrixMode(GL_MODELVIEW);</span><br><span class="line">    gluLookAt(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    glColor3f(<span class="number">1.0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    glutWireTeapot(<span class="number">3</span>);</span><br><span class="line">    glFlush();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    glutInit( &amp; argc, argv);</span><br><span class="line">    glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);</span><br><span class="line">    glutInitWindowPosition(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    glutInitWindowSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">    glutCreateWindow(<span class="string">"OpenGL 3D View"</span>);</span><br><span class="line">    init();</span><br><span class="line">    glutDisplayFunc(<span class="built_in">display</span>);</span><br><span class="line">    glutMainLoop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o opengl opengl.c -lGL -lGLU -lglut    <span class="comment"># 编译</span></span><br><span class="line">./opengl                                    <span class="comment"># 之后执行</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>正常的话能看到一个茶壶。</li>
</ul>
<p><img data-src="/images/opengl_pot.png" alt="茶壶"></p>
]]></content>
      <categories>
        <category>计算机拾遗</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017/08/01/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo code block in bullet lists problem</title>
    <url>/2018/05/06/hexo-notes1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="解决Hexo有序列表编号重置问题"><a href="#解决Hexo有序列表编号重置问题" class="headerlink" title="解决Hexo有序列表编号重置问题"></a>解决Hexo有序列表编号重置问题</h1><p>参考链接: <a href="https://gist.github.com/clintel/1155906/1eec0c2a5b5494c84e77b5298197a7e33477372c" target="_blank" rel="noopener">link</a></p>
<a id="more"></a>

<h2 id="可采用markdown书写方式-源代码"><a href="#可采用markdown书写方式-源代码" class="headerlink" title="可采用markdown书写方式-源代码"></a>可采用markdown书写方式-源代码</h2><p>源代码链接: <a href="https://gist.github.com/liziwl/b4259638c29d468c384e2b7fcec89895" target="_blank" rel="noopener">link</a></p>
<h2 id="渲染效果"><a href="#渲染效果" class="headerlink" title="渲染效果"></a>渲染效果</h2><ol>
<li>This is the start of a new bullet list. Hey, where is my fenced code? ```<br>Code<br>More Code<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2.  Well that was disappointing. How about we indent and use backticks together?</span><br></pre></td></tr></table></figure>
<pre><code>Code
More Code
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. No such luck. This time, with separation too:</span><br></pre></td></tr></table></figure>
</code></pre>
 Code<br> More Code<pre><code>
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>简析TCP的三次握手与四次分手</title>
    <url>/2017/10/09/http-tips/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="TCP是什么？"><a href="#TCP是什么？" class="headerlink" title="TCP是什么？"></a>TCP是什么？</h1><p>具体的关于TCP是什么，我不打算详细的说了；当你看到这篇文章时，我想你也知道TCP的概念了，想要更深入的了解TCP的工作，我们就继续。它只是一个超级麻烦的协议，而它又是互联网的基础，也是每个程序员必备的基本功。</p>
<a id="more"></a>

<p>首先来看看OSI的七层模型：</p>
<p><img data-src="/images/1010_1.jpg" alt="OSI模型"></p>
<p>我们需要知道TCP工作在网络OSI的七层模型中的第四层——Transport层，IP在第三层——Network层，ARP在第二层——Data Link层；在第二层上的数据，我们把它叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。 同时，我们需要简单的知道，数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封装的过程。 在OSI七层模型中，每一层的作用和对应的协议如下：</p>
<p><img data-src="/images/1010_2.jpg" alt="OSI模型解释"></p>
<p>TCP是一个协议，那这个协议是如何定义的，它的数据格式是什么样子的呢？要进行更深层次的剖析，就需要了解，甚至是熟记TCP协议中每个字段的含义。哦，来吧。</p>
<p><img data-src="/images/1010_3.jpg" alt="TCP协议"></p>
<p>上面就是TCP协议头部的格式，由于它太重要了，是理解其它内容的基础，下面就将每个字段的信息都详细的说明一下。</p>
<ul>
<li>Source Port和Destination Port:分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接；</li>
<li>Sequence Number:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题；</li>
<li>Acknowledgment Number:32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。主要用来解决不丢包的问题；</li>
<li>Offset:给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节；</li>
<li>TCP Flags:TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为<code>URG</code>，<code>ACK</code>，<code>PSH</code>，<code>RST</code>，<code>SYN</code>，<code>FIN</code>。每个标志位的意思如下：<ul>
<li>URG：此标志表示TCP包的紧急指针域（后面马上就要说到）有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据；</li>
<li>ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0；</li>
<li>PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；</li>
<li>RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；</li>
<li>SYN：表示同步序号，用来建立连接。<code>SYN</code>标志位和<code>ACK</code>标志位搭配使用，当连接请求的时候，<code>SYN</code>=1，<code>ACK</code>=0；连接被响应的时候，<code>SYN</code>=1，<code>ACK</code>=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有<code>SYN</code>的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手；</li>
<li>FIN： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送<code>FIN</code>标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。</li>
</ul>
</li>
<li>Window:窗口大小，也就是有名的滑动窗口，用来进行流量控制；这是一个复杂的问题，这篇博文中并不会进行总结的；</li>
</ul>
<p>好了，基本知识都已经准备好了，开始下一段的征程吧。</p>
<h1 id="三次握手又是什么？"><a href="#三次握手又是什么？" class="headerlink" title="三次握手又是什么？"></a>三次握手又是什么？</h1><p>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。这就是面试中经常会被问到的TCP三次握手。只是了解TCP三次握手的概念，对你获得一份工作是没有任何帮助的，你需要去了解TCP三次握手中的一些细节。先来看图说话。</p>
<p><img data-src="/images/1010_4.jpg" alt="TCP三次握手"></p>
<p>多么清晰的一张图，当然了，也不是我画的，我也只是引用过来说明问题了。</p>
<ol>
<li>第一次握手：建立连接。客户端发送连接请求报文段，将<code>SYN</code>位置为1，<code>Sequence Number</code>为x；然后，客户端进入<code>SYN_SEND</code>状态，等待服务器的确认；</li>
<li>第二次握手：服务器收到<code>SYN</code>报文段。服务器收到客户端的<code>SYN</code>报文段，需要对这个<code>SYN</code>报文段进行确认，设置<code>Acknowledgment Number</code>为x+1(Sequence Number+1)；同时，自己自己还要发送<code>SYN</code>请求信息，将<code>SYN</code>位置为1，<code>Sequence Number</code>为y；服务器端将上述所有信息放到一个报文段（即<code>SYN+ACK</code>报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li>
<li>第三次握手：客户端收到服务器的<code>SYN+ACK</code>报文段。然后将<code>Acknowledgment Number</code>设置为y+1，向服务器发送<code>ACK</code>报文段，这个报文段发送完毕以后，客户端和服务器端都进入<code>ESTABLISHED</code>状态，完成TCP三次握手。</li>
</ol>
<p>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</p>
<h1 id="那四次分手呢？"><a href="#那四次分手呢？" class="headerlink" title="那四次分手呢？"></a>那四次分手呢？</h1><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p>
<ol>
<li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置<code>Sequence Number</code>和<code>Acknowledgment Number</code>，向主机2发送一个<code>FIN</code>报文段；此时，主机1进入<code>FIN_WAIT_1</code>状态；这表示主机1没有数据要发送给主机2了；</li>
<li>第二次分手：主机2收到了主机1发送的<code>FIN</code>报文段，向主机1回一个<code>ACK</code>报文段，<code>Acknowledgment Number</code>为<code>Sequence Number</code>加1；主机1进入<code>FIN_WAIT_2</code>状态；主机2告诉主机1，我“同意”你的关闭请求；</li>
<li>第三次分手：主机2向主机1发送<code>FIN</code>报文段，请求关闭连接，同时主机2进入<code>LAST_ACK</code>状态；</li>
<li>第四次分手：主机1收到主机2发送的<code>FIN</code>报文段，向主机2发送<code>ACK</code>报文段，然后主机1进入<code>TIME_WAIT</code>状态；主机2收到主机1的<code>ACK</code>报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。<br>至此，TCP的四次分手就这么愉快的完成了。当你看到这里，你的脑子里会有很多的疑问，很多的不懂，感觉很凌乱；没事，我们继续总结。</li>
</ol>
<h1 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h1><p>既然总结了TCP的三次握手，那为什么非要三次呢？怎么觉得两次就可以完成了。那TCP为什么非要进行三次连接呢？在谢希仁的《计算机网络》中是这样说的：</p>
<blockquote>
<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
</blockquote>
<p>在书中同时举了一个例子，如下：</p>
<blockquote>
<p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p>
</blockquote>
<p>这就很明白了，防止了服务器端的一直等待而浪费资源。</p>
<h1 id="为什么要四次分手"><a href="#为什么要四次分手" class="headerlink" title="为什么要四次分手"></a>为什么要四次分手</h1><p>那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p>
<ul>
<li><code>FIN_WAIT_1</code>: 这个状态要好好解释一下，其实<code>FIN_WAIT_1</code>和<code>FIN_WAIT_2</code>状态的真正含义都是表示等待对方的<code>FIN</code>报文。而这两种状态的区别是：<code>FIN_WAIT_1</code>状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了<code>FIN</code>报文，此时该SOCKET即进入到<code>FIN_WAIT_1</code>状态。而当对方回应<code>ACK</code>报文后，则进入到<code>FIN_WAIT_2</code>状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应<code>ACK</code>报文，所以<code>FIN_WAIT_1</code>状态一般是比较难见到的，而<code>FIN_WAIT_2</code>状态还有时常常可以用netstat看到。<strong>（主动方）</strong></li>
<li><code>FIN_WAIT_2</code>：上面已经详细解释了这种状态，实际上<code>FIN_WAIT_2</code>状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(<code>ACK</code>信息)，稍后再关闭连接。<strong>（主动方）</strong></li>
<li><code>CLOSE_WAIT</code>：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送<code>FIN</code>报文给自己，你系统毫无疑问地会回应一个<code>ACK</code>报文给对方，此时则进入到<code>CLOSE_WAIT</code>状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在<code>CLOSE_WAIT</code>状态下，需要完成的事情是等待你去关闭连接。<strong>（被动方）</strong></li>
<li><code>LAST_ACK</code>: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的<code>ACK</code>报文。当收到<code>ACK</code>报文后，也即可以进入到<code>CLOSED</code>可用状态了。<strong>（被动方）</strong></li>
<li><code>TIME_WAIT</code>: 表示收到了对方的<code>FIN</code>报文，并发送出了<code>ACK</code>报文，就等2MSL后即可回到<code>CLOSED</code>可用状态了。如果<code>FIN_WAIT_1</code>状态下，收到了对方同时带<code>FIN</code>标志和<code>ACK</code>标志的报文时，可以直接进入到<code>TIME_WAIT</code>状态，而无须经过<code>FIN_WAIT_2</code>状态。<strong>（主动方）</strong></li>
<li><code>CLOSED</code>: 表示连接中断。</li>
</ul>
]]></content>
      <categories>
        <category>编程笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu 16.04 安装 hadoop</title>
    <url>/2018/03/16/install-hadoop/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Copy line by line and paste to an interactive shell</p>
<a id="more"></a>

<h1 id="Create-a-new-user-named-hadoop"><a href="#Create-a-new-user-named-hadoop" class="headerlink" title="Create a new user named hadoop"></a>Create a new user named hadoop</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo useradd -m hadoop -s /bin/bash     <span class="comment"># 创建hadoop用户</span></span><br><span class="line">sudo passwd hadoop          <span class="comment"># 修改密码</span></span><br><span class="line">sudo adduser hadoop sudo    <span class="comment"># 增加管理员权限</span></span><br></pre></td></tr></table></figure>

<h1 id="Log-out-current-user-log-in-hadoop"><a href="#Log-out-current-user-log-in-hadoop" class="headerlink" title="Log out current user, log in hadoop"></a>Log out current user, log in hadoop</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update         <span class="comment"># Update system</span></span><br></pre></td></tr></table></figure>

<h1 id="Install-ssh"><a href="#Install-ssh" class="headerlink" title="Install ssh"></a>Install ssh</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir .ssh                  <span class="comment"># 可能该文件已存在，不影响</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh/</span><br><span class="line">ssh-keygen -t rsa           <span class="comment"># 会有提示，都按回车就可以</span></span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys  <span class="comment"># 加入授权</span></span><br></pre></td></tr></table></figure>

<h1 id="Install-Java"><a href="#Install-Java" class="headerlink" title="Install Java"></a>Install Java</h1><p>参照这个安装Java JDK，推荐安装Oracle </p>
<blockquote>
<p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-get-on-ubuntu-16-04" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-get-on-ubuntu-16-04</a></p>
</blockquote>
<ol>
<li><p>安装openjdk</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update <span class="comment"># 更新软件包列表</span></span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装oracle Java JDK</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:webupd8team/java <span class="comment"># 添加仓库源</span></span><br><span class="line">sudo apt-get update <span class="comment"># 更新软件包列表</span></span><br><span class="line">sudo apt-get install oracle-java8-installer</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>已经装了多种Java版本，可以选择更换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --config java</span><br></pre></td></tr></table></figure>

<h1 id="Download-amp-Install-Hadoop"><a href="#Download-amp-Install-Hadoop" class="headerlink" title="Download &amp; Install Hadoop"></a>Download &amp; Install Hadoop</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.0.0/hadoop-3.0.0.tar.gz -P ~/Downloads</span><br><span class="line">sudo tar zxvf ~/Downloads/hadoop-3.0.0.tar.gz -C /usr/<span class="built_in">local</span></span><br><span class="line">sudo mv /usr/<span class="built_in">local</span>/hadoop-3.0.0 /usr/<span class="built_in">local</span>/hadoop</span><br><span class="line">sudo chown -R hadoop /usr/<span class="built_in">local</span>/hadoop</span><br></pre></td></tr></table></figure>

<h1 id="Configure-hadoop"><a href="#Configure-hadoop" class="headerlink" title="Configure hadoop"></a>Configure hadoop</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"export JAVA_HOME=<span class="variable">$(readlink -f $(which java)</span> | sed "</span>s:bin/java::<span class="string">")"</span> &gt;&gt; /usr/<span class="built_in">local</span>/hadoop/etc/hadoop/hadoop-env.sh</span><br></pre></td></tr></table></figure>

<h2 id="Configure-core-site-xml"><a href="#Configure-core-site-xml" class="headerlink" title="Configure core-site.xml"></a>Configure core-site.xml</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/<span class="built_in">local</span>/hadoop/etc/hadoop/core-site.xml</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;file:&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;tmp&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;description&gt;Abase for other temporary directories.&lt;&#x2F;description&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;hdfs:&#x2F;&#x2F;localhost:9000&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Configure-hdfs-site-xml"><a href="#Configure-hdfs-site-xml" class="headerlink" title="Configure hdfs-site.xml"></a>Configure hdfs-site.xml</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/<span class="built_in">local</span>/hadoop/etc/hadoop/hdfs-site.xml</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.name.dir&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;file:&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;tmp&#x2F;dfs&#x2F;name&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.datanode.data.dir&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;file:&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;tmp&#x2F;dfs&#x2F;data&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Configure-environment"><a href="#Configure-environment" class="headerlink" title="Configure environment"></a>Configure environment</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"</span></span><br><span class="line"><span class="string">export JAVA_HOME=<span class="variable">$(readlink -f $(which java)</span> | sed "</span>s:/jre/bin/java::<span class="string">")</span></span><br><span class="line"><span class="string">export PATH=\$PATH:\$JAVA_HOME/bin</span></span><br><span class="line"><span class="string">export PATH=\$PATH:\$HADOOP_HOME/bin</span></span><br><span class="line"><span class="string">export HADOOP_HOME=/usr/local/hadoop</span></span><br><span class="line"><span class="string">export HADOOP_CLASSPATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib/tools.jar</span></span><br><span class="line"><span class="string">"</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h1 id="start-hadoop"><a href="#start-hadoop" class="headerlink" title="start hadoop"></a>start hadoop</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/hadoop</span><br><span class="line">bin/hdfs namenode -format      <span class="comment"># namenode 格式化</span></span><br><span class="line">sbin/start-dfs.sh              <span class="comment"># 开启守护进程</span></span><br><span class="line">jps                             <span class="comment"># 判断是否启动成功</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：勿反复使用hdfs namenode -format 命令 ,如果修改配置后选择N</p>
<p>如需关闭hadoop 进程则可以使用 stop-dfs.sh，第二次启动直接运行 start-dfs.sh</p>
</blockquote>
<h1 id="Test-hadoop"><a href="#Test-hadoop" class="headerlink" title="Test hadoop"></a>Test hadoop</h1><p>Save source code from the url, as WordCount.java in <code>/usr/local/hadoop</code>.</p>
<blockquote>
<p>WordCount1.0 ver</p>
<p><a href="http://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html" target="_blank" rel="noopener">http://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/hadoop</span><br><span class="line">bin/hadoop com.sun.tools.javac.Main WordCount.java</span><br><span class="line">jar -cvf wordcount.jar *.class</span><br><span class="line"></span><br><span class="line">bin/hadoop fs -mkdir /input_wordcount</span><br><span class="line">bin/hadoop fs -put input/* /input_wordcount/ </span><br><span class="line"></span><br><span class="line">bin/hadoop fs -ls /                     <span class="comment"># 查看文件</span></span><br><span class="line">bin/hadoop fs -ls /input_wordcount          <span class="comment"># 查看file1 file2</span></span><br><span class="line">bin/hadoop fs -cat /input_wordcount/file1   <span class="comment"># 打印文件</span></span><br><span class="line">bin/hadoop jar wordcount.jar WordCount /input_wordcount /output_wordcount   <span class="comment"># 进行运算</span></span><br><span class="line"></span><br><span class="line">bin/hadoop fs -ls /output_wordcount</span><br><span class="line">bin/hadoop fs -cat /output_wordcount/part-r-00000     <span class="comment"># 查看结果</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机拾遗</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo中渲染MathJax数学公式</title>
    <url>/2017/09/19/mathjax-in-hexo/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在用markdown写技术文档时，免不了会碰到数学公式。常用的Markdown编辑器都会集成Mathjax，用来渲染文档中的类Latex格式书写的数学公式。基于Hexo搭建的个人博客，默认情况下渲染数学公式却会出现各种各样的问题。</p>
<a id="more"></a>

<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>Hexo默认使用”hexo-renderer-marked”引擎渲染网页，该引擎会把一些特殊的markdown符号转换为相应的html标签，比如在markdown语法中，下划线’_’代表斜体，会被渲染引擎处理为<code>&lt;em&gt;</code>标签。</p>
<p>因为类Latex格式书写的数学公式下划线 ‘_’ 表示下标，有特殊的含义，如果被强制转换为<code>&lt;em&gt;</code>标签，那么MathJax引擎在渲染数学公式的时候就会出错。例如，$x_i$在开始被渲染的时候，处理为$x<code>&lt;em&gt;</code>i<code>&lt;/em&gt;</code>$，这样MathJax引擎就认为该公式有语法错误，因为不会渲染。</p>
<p>类似的语义冲突的符号还包括’*’, ‘{‘, ‘}’, ‘\’等。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决方案有很多，可以网上搜下，为了节省大家的时间，这里只提供亲身测试过的最靠谱的方法。</p>
<p>更换Hexo的markdown渲染引擎，<a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="noopener">hexo-renderer-kramed</a>引擎是在默认的渲染引擎<a href="https://github.com/hexojs/hexo-renderer-marked" target="_blank" rel="noopener">hexo-renderer-marked</a>的基础上修改了一些bug，两者比较接近，也比较轻量级。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>执行上面的命令即可，先卸载原来的渲染引擎，再安装新的。</p>
<p>然后，跟换引擎后行间公式可以正确渲染了，但是这样还没有完全解决问题，行内公式的渲染还是有问题，因为<a href="https://github.com/sun11/hexo-renderer-kramed" target="_blank" rel="noopener">hexo-renderer-kramed</a>引擎也有语义冲突的问题。接下来到博客根目录下，找到node_modules\kramed\lib\rules\inline.js，把第11行的escape变量的值做相应的修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  escape: &#x2F;^\\([\\&#96;*&#123;&#125;\[\]()#$+\-.!_&gt;])&#x2F;,</span><br><span class="line">  escape: &#x2F;^\\([&#96;*\[\]()#$+\-.!_&gt;])&#x2F;,</span><br></pre></td></tr></table></figure>
<p>这一步是在原基础上取消了对\,{,}的转义(escape)。</p>
<p>同时把第20行的em变量也要做相应的修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;  em: &#x2F;^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)&#x2F;,</span><br><span class="line">  em: &#x2F;^\*((?:\*\*|[\s\S])+?)\*(?!\*)&#x2F;,</span><br></pre></td></tr></table></figure>
<p>重新启动hexo（先clean再generate), 问题完美解决。哦，如果不幸还没解决的话，看看是不是还需要在使用的主题中配置mathjax开关。</p>
<h1 id="在主题中开启mathjax开关"><a href="#在主题中开启mathjax开关" class="headerlink" title="在主题中开启mathjax开关"></a>在主题中开启mathjax开关</h1><p>如何使用了主题了，别忘了在主题（Theme）中开启mathjax开关，下面以next主题为例，介绍下如何打开mathjax开关。</p>
<p>进入到主题目录，找到_config.yml配置问题，把mathjax默认的false修改为true，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: true</span><br></pre></td></tr></table></figure>
<p>别着急，这样还不够，还需要在文章的Front-matter里打开mathjax开关，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: index.html</span><br><span class="line">date: 2016-12-28 21:01:30</span><br><span class="line">tags:</span><br><span class="line">mathjax: true</span><br><span class="line">--</span><br></pre></td></tr></table></figure>
<p>不要嫌麻烦，之所以要在文章头里设置开关，是因为考虑只有在用到公式的页面才加载 Mathjax，这样不需要渲染数学公式的页面的访问速度就不会受到影响了。而且不应用Mathjax的页面就不再需要考虑<code>$</code>符号转义的问题</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo 音乐插件测试</title>
    <url>/2019/02/24/music-test/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>
    <div id="aplayer-zKitTLxk" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="720390782" data-server="xiami" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>

<a id="more"></a>

<h1 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-aplayer --save</span><br><span class="line">npm install hexo-tag-dplayer --save</span><br></pre></td></tr></table></figure>

<p>插件 Github 仓库：</p>
<ul>
<li><a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="noopener">https://github.com/MoePlayer/hexo-tag-aplayer</a></li>
<li><a href="https://github.com/MoePlayer/hexo-tag-dplayer" target="_blank" rel="noopener">https://github.com/MoePlayer/hexo-tag-dplayer</a></li>
</ul>
<h1 id="修改-Hexo-根目录配置文件-config-yml"><a href="#修改-Hexo-根目录配置文件-config-yml" class="headerlink" title="修改 Hexo 根目录配置文件 _config.yml"></a>修改 Hexo 根目录配置文件 <code>_config.yml</code></h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">aplayer:</span></span><br><span class="line">  <span class="attr">meting:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>以下引用插件作者说明：</p>
<p>Now you can use in your post:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- Simple example (id, server, type)  --&gt;</span><br><span class="line">&#123;% meting &quot;60198&quot; &quot;netease&quot; &quot;playlist&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- Advanced example --&gt;</span><br><span class="line">&#123;% meting &quot;60198&quot; &quot;netease&quot; &quot;playlist&quot; &quot;autoplay&quot; &quot;mutex:false&quot; &quot;listmaxheight:340px&quot; &quot;preload:none&quot; &quot;theme:#ad7a86&quot;%&#125;</span><br></pre></td></tr></table></figure>

<p>The options are shown below:</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td><strong>required</strong></td>
<td>song id / playlist id / album id / search keyword</td>
</tr>
<tr>
<td>server</td>
<td><strong>required</strong></td>
<td>Music platform: <code>netease</code>, <code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code></td>
</tr>
<tr>
<td>type</td>
<td><strong>required</strong></td>
<td><code>song</code>, <code>playlist</code>, <code>album</code>, <code>search</code>, <code>artist</code></td>
</tr>
<tr>
<td>fixed</td>
<td><code>false</code></td>
<td>Enable fixed mode</td>
</tr>
<tr>
<td>mini</td>
<td><code>false</code></td>
<td>Enable mini mode</td>
</tr>
<tr>
<td>loop</td>
<td><code>all</code></td>
<td>Player loop play, values: ‘all’, ‘one’, ‘none’</td>
</tr>
<tr>
<td>order</td>
<td><code>list</code></td>
<td>Player play order, values: ‘list’, ‘random’</td>
</tr>
<tr>
<td>volume</td>
<td>0.7</td>
<td>Default volume, notice that player will remember user setting, default volume will not work after user set volume themselves</td>
</tr>
<tr>
<td>lrctype</td>
<td>0</td>
<td>Lyric type</td>
</tr>
<tr>
<td>listfolded</td>
<td><code>false</code></td>
<td>Indicate whether list should folded at first</td>
</tr>
<tr>
<td>autoplay</td>
<td><code>false</code></td>
<td>Autoplay song(s), not supported by mobile browsers</td>
</tr>
<tr>
<td>mutex</td>
<td><code>true</code></td>
<td>Pause other players when this player playing</td>
</tr>
<tr>
<td>listmaxheight</td>
<td><code>340px</code></td>
<td>Max height of play list</td>
</tr>
<tr>
<td>preload</td>
<td><code>auto</code></td>
<td>The way to load music, can be <code>none</code>, <code>metadata</code>, <code>auto</code></td>
</tr>
<tr>
<td>storagename</td>
<td><code>metingjs</code></td>
<td>LocalStorage key that store player setting</td>
</tr>
<tr>
<td>theme</td>
<td><code>#ad7a86</code></td>
<td>Theme color</td>
</tr>
</tbody></table>
<p>Read section <a href="#customization-new-in-30">customization</a>  to learn how to configure self-host meting api server in <code>hexo-tag-aplayer</code> and other configuration.</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu安装ngrok服务端</title>
    <url>/2018/03/05/ngrok/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>如果要有实现内网穿透的功能ngrok是个不错的选择，这篇就讲下如何配置ngrox。</p>
<p>使用的是开源的<a href="https://github.com/inconshreveable/ngrok" target="_blank" rel="noopener">ngrox1.0</a>，目前2.0版本尚未开源。</p>
<a id="more"></a>

<h1 id="编译-ngrok"><a href="#编译-ngrok" class="headerlink" title="编译 ngrok"></a>编译 ngrok</h1><p>假定工作目录为<code>/home/ubuntu/opt/</code>，这个随意，根据自己使用改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install build-essential golang mercurial git</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="built_in">cd</span> ngrok</span><br><span class="line"><span class="comment">#设置域名，注意改成你自己的域名</span></span><br><span class="line"><span class="built_in">export</span> NGROK_DOMAIN=<span class="string">"your.domain.com"</span></span><br><span class="line"><span class="comment">#设置go编译路径</span></span><br><span class="line"><span class="built_in">export</span> GOPATH=/home/ubuntu/opt/ngrok</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成证书</span></span><br><span class="line">openssl genrsa -out rootCA.key 2048</span><br><span class="line">openssl req -x509 -new -nodes -key rootCA.key -subj <span class="string">"/CN=<span class="variable">$NGROK_DOMAIN</span>"</span> -days 5000 -out rootCA.pem</span><br><span class="line">openssl genrsa -out device.key 2048</span><br><span class="line">openssl req -new -key device.key -subj <span class="string">"/CN=<span class="variable">$NGROK_DOMAIN</span>"</span> -out device.csr</span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</span><br><span class="line">cp rootCA.pem assets/client/tls/ngrokroot.crt</span><br><span class="line">cp device.crt assets/server/tls/snakeoil.crt</span><br><span class="line">cp device.key assets/server/tls/snakeoil.key</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">sudo make release-server release-client</span><br></pre></td></tr></table></figure>

<p>此时，如果没有报错的话，<code>./ngrok/bin</code>目录下会有<code>ngrok</code>和<code>ngrokd</code>可执行文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">└── bin</span><br><span class="line">    ├── go-bindata</span><br><span class="line">    ├── ngrok</span><br><span class="line">    └── ngrokd</span><br></pre></td></tr></table></figure>

<h1 id="运行-ngrok服务端"><a href="#运行-ngrok服务端" class="headerlink" title="运行 ngrok服务端"></a>运行 ngrok服务端</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/opt/ngrok/bin/</span><br><span class="line">./ngrokd -domain=<span class="string">"your.domain.com"</span> -httpAddr=<span class="string">":8081"</span> -httpsAddr=<span class="string">":8082"</span></span><br></pre></td></tr></table></figure>
<p>正常的话会显示下面类似的信息。</p>
<p><img data-src="/images/0305.png" alt="信息"></p>
<h1 id="设置DNS解析"><a href="#设置DNS解析" class="headerlink" title="设置DNS解析"></a>设置DNS解析</h1><p>在域名服务商，设置<code>your.domain.com</code>域名解析到运行ngrok服务器的IP。</p>
<p>访问<a href="http://test.your.domain.com:8081/" target="_blank" rel="noopener">http://test.your.domain.com:8081</a><br>如果出现</p>
<blockquote>
<p>Tunnel test.your.domain.com:8081 not found<br>就说明服务器搭建成功。</p>
</blockquote>
<p>接下来设置客户端。</p>
]]></content>
      <categories>
        <category>计算机拾遗</category>
      </categories>
  </entry>
  <entry>
    <title>python-中文编码</title>
    <url>/2017/10/01/python-notes1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Python-UnicodeEncodeError-‘gbk’-codec-can’t-encode-character-解决方法"><a href="#Python-UnicodeEncodeError-‘gbk’-codec-can’t-encode-character-解决方法" class="headerlink" title="Python UnicodeEncodeError: ‘gbk’ codec can’t encode character 解决方法"></a>Python UnicodeEncodeError: ‘gbk’ codec can’t encode character 解决方法</h1><p>使用Python写文件的时候，或者将网络数据流写入到本地文件的时候，大部分情况下会遇到：<code>UnicodeEncodeError: &#39;gbk&#39; codec can&#39;t encode character &#39;\xa0&#39; in position ...</code> 这个问题。 网络上有很多类似的文件讲述如何解决这个问题，但是无非就是encode，decode相关的，这是导致该问题出现的真正原因吗？不是的。</p>
<a id="more"></a>

<p>很多时候，我们使用了decode和encode，试遍了各种编码，utf-8, gbk, gb2312等等，该有的编码都试遍了，可是编译的时候仍然出现： <code>UnicodeEncodeError: &#39;gbk&#39; codec can&#39;t encode character &#39;\xa0&#39; in position XXX</code><br>在windows下面编写python脚本，编码问题很严重。</p>
<p>将网络数据流写入文件时时，我们会遇到几个编码：</p>
<ol>
<li><code>#encoding=&#39;XXX&#39;</code> 这里(也就是python文件第一行的内容)的编码是指该python脚本文件本身的编码，无关紧要。只要XXX和文件本身的编码相同就行了。 比如notepad++ “格式”菜单里面里可以设置各种编码，这时需要保证该菜单里设置的编码和encoding XXX相同就行了，不同的话会报错</li>
<li>网络数据流的编码：比如获取网页，那么网络数据流的编码就是网页的编码。需要使用decode解码成unicode编码。</li>
<li>目标文件的编码，要将网络数据流的编码写入到新文件，那么我么需要指定新文件的编码。写文件代码如：<code>f.write(txt)</code>，那么txt是一个字符串，它是通过decode解码过的字符串。</li>
</ol>
<p>关键点就要来了：目标文件的编码是导致标题所指问题的罪魁祸首。如果我们打开一个文件：<code>f = open(&quot;out.html&quot;,&quot;w&quot;)</code>，在windows下面，新文件的默认编码是gbk，这样的话，python解释器会用gbk编码去解析我们的网络数据流txt，然而txt此时已经是decode过的unicode编码，这样的话就会导致解析不了，出现上述问题。 解决的办法就是，改变目标文件的编码：<code>f = open(&quot;out.html&quot;,&quot;w&quot;,encoding=&#39;utf-8&#39;)</code>。这样，问题将不复存在。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="http://www.jb51.net/article/64816.htm" target="_blank" rel="noopener">Python UnicodeEncodeError: ‘gbk’ codec can’t encode character 解决方法</a></p>
]]></content>
      <categories>
        <category>编程笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Python 精简依赖 -- pip-chill</title>
    <url>/2019/10/11/python-pypi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>开发时直接 <code>pip freeze</code> 得到的依赖文件表太乱了，就想有没有包能实现分析依赖让依赖文件表可读性更好。查阅后发现还真有这样的包 –pip-chill (<a href="https://pypi.org/project/pip-chill/)%E3%80%82" target="_blank" rel="noopener">https://pypi.org/project/pip-chill/)。</a></p>
<a id="more"></a>

<h1 id="最简单的依赖管理"><a href="#最简单的依赖管理" class="headerlink" title="最简单的依赖管理"></a>最简单的依赖管理</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装虚拟环境</span></span><br><span class="line">pip install virtualenv</span><br><span class="line">virtualenv --no-site-packages venv</span><br><span class="line"></span><br><span class="line">pip freeze &gt; requirements.txt <span class="comment"># 输出本地包环境至文件</span></span><br><span class="line">pip install -r requirements.txt <span class="comment">#安装本地依赖</span></span><br></pre></td></tr></table></figure>

<h1 id="精简依赖管理"><a href="#精简依赖管理" class="headerlink" title="精简依赖管理"></a>精简依赖管理</h1><p>pip-chill (<a href="https://pypi.org/project/pip-chill/" target="_blank" rel="noopener">https://pypi.org/project/pip-chill/</a>)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> venv/bin/activate <span class="comment"># 激活环境</span></span><br><span class="line">pip-chill <span class="comment"># with version</span></span><br><span class="line">pip-chill --no-version <span class="comment"># no version</span></span><br><span class="line">pip-chill -v <span class="comment"># list package dependencies too and version</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程笔记</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式中的括号用法</title>
    <url>/2017/10/08/regular-expression/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="正则表达式的-的意思。"><a href="#正则表达式的-的意思。" class="headerlink" title="正则表达式的() [] {}的意思。"></a>正则表达式的() [] {}的意思。</h1><ul>
<li><code>()</code> 是为了提取匹配的字符串。表达式中有几个()就有几个相应的匹配字符串。</li>
<li><code>(\s*)</code> 表示连续空格的字符串。</li>
<li><code>[]</code> 是定义匹配的字符范围。比如 <code>[a-zA-Z0-9]</code> 表示相应位置的字符要匹配英文字符和数字。<code>[\s*]</code> 表示空格或者<code>*</code> 号。</li>
<li><code>{}</code> 一般用来表示匹配的长度，比如<code>\s{3}</code> 表示匹配三个空格，<code>\s[1,3]</code>表示匹配一到三个空格。</li>
<li><code>(0-9)</code> 匹配 <code>&#39;0-9&#39;</code> 本身。 <code>[0-9]*</code> 匹配数字（注意后面有* ，可以为空）<code>[0-9]+</code> 匹配数字（注意后面有 +，不可以为空）<code>{1-9}</code> 写法错误。</li>
<li><code>[0-9]{0,9}</code> 表示长度为 0 到 9 的数字字符串。</li>
</ul>
<a id="more"></a>

<h2 id="正则表达式小括号的多义性"><a href="#正则表达式小括号的多义性" class="headerlink" title="正则表达式小括号的多义性"></a>正则表达式小括号的多义性</h2><p>小括号在正则表达式这有以下意义</p>
<ul>
<li>限定量词作用的范围</li>
<li>限定多选结构的范围</li>
<li>为反向引用捕获文本</li>
<li>分组捕获</li>
<li>只分组不捕获</li>
<li>前瞻</li>
</ul>
<h3 id="限定量词作用的范围"><a href="#限定量词作用的范围" class="headerlink" title="限定量词作用的范围"></a>限定量词作用的范围</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/(Matz)?/</span>; <span class="comment">// 0或1个Matz</span></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/(Matz)+/</span>; <span class="comment">// 1个以上Matz</span></span><br><span class="line"><span class="keyword">var</span> reg3 = <span class="regexp">/(Matz)*/</span>; <span class="comment">// 0或多个Matz</span></span><br></pre></td></tr></table></figure>

<h3 id="限定多选结构的范围"><a href="#限定多选结构的范围" class="headerlink" title="限定多选结构的范围"></a>限定多选结构的范围</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(Matz|Eich)/</span></span><br><span class="line">reg.test(<span class="string">'Matz'</span>) <span class="comment">// =&gt; true</span></span><br><span class="line">reg.test(<span class="string">'Eich'</span>) <span class="comment">// =&gt; true</span></span><br><span class="line">reg.test(<span class="string">'John'</span>) <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>

<h3 id="为反向引用捕获文本"><a href="#为反向引用捕获文本" class="headerlink" title="为反向引用捕获文本"></a>为反向引用捕获文本</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(boy)\1/</span> <span class="comment">// 相当于 /boyboy/</span></span><br><span class="line">reg.test(<span class="string">'boy'</span>) <span class="comment">// =&gt; false</span></span><br><span class="line">reg.test(<span class="string">'boyboy'</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> reg /(boy)(girl)\<span class="number">1</span>\<span class="number">2</span>/</span><br><span class="line">reg.test(<span class="string">'boygirlboygirl'</span>) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<h3 id="分组捕获"><a href="#分组捕获" class="headerlink" title="分组捕获"></a>分组捕获</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/(\d&#123;3&#125;) (\d&#123;3&#125;)/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'111 222'</span></span><br><span class="line">str.replace(reg1, <span class="string">'$2 $1'</span>) <span class="comment">// =&gt; '222 111' , 注意这里的$2,$1，存放了匹配的字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/(\d&#123;3&#125;)(\d&#123;4&#125;)(\d&#123;4&#125;)/</span></span><br><span class="line"><span class="keyword">var</span> mobile = <span class="string">'13522722724'</span></span><br><span class="line">reg2.test(mobile)</span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">1</span> <span class="comment">// =&gt; 135</span></span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">2</span> <span class="comment">// =&gt; 2272</span></span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">3</span> <span class="comment">// =&gt; 2724</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> reg3 = <span class="regexp">/(\d&#123;3&#125;)(\d&#123;4&#125;)(\d&#123;4&#125;)/</span></span><br><span class="line"><span class="keyword">var</span> mobile = <span class="string">'13522722724'</span></span><br><span class="line">mobile.replace(reg3, <span class="string">'$1 $2 $3'</span>) <span class="comment">// =&gt; '135 2272 2724'</span></span><br></pre></td></tr></table></figure>

<h3 id="只分组不捕获-和-“-”-一起"><a href="#只分组不捕获-和-“-”-一起" class="headerlink" title="只分组不捕获(和 “?:” 一起)"></a>只分组不捕获(和 “?:” 一起)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(?:\d+)/</span></span><br><span class="line">reg.test(<span class="string">'13522722724'</span>)</span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">1</span> <span class="comment">// =&gt; '' 不存储匹配的元素</span></span><br></pre></td></tr></table></figure>
<p>较长的正则表达式中，反向引用会降低匹配速度，性能降低，不需要反向引用时应使用分组不捕获。</p>
<h3 id="前瞻（lookahead，和-“-”-一起）"><a href="#前瞻（lookahead，和-“-”-一起）" class="headerlink" title="前瞻（lookahead，和 “?=” 一起）"></a>前瞻（lookahead，和 “?=” 一起）</h3><p>它告诉正则表达式向前看一些字符但不移动位置，前瞻不匹配任何字符只匹配文本中的特定位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(John) (?=Resig)/</span></span><br><span class="line">reg.test(<span class="string">'John'</span>) <span class="comment">// =&gt; false</span></span><br><span class="line">reg.test(<span class="string">'John Backus'</span>) <span class="comment">// =&gt; false</span></span><br><span class="line">reg.test(<span class="string">'John Reisg'</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">RegExp</span>.$<span class="number">1</span> <span class="comment">// =&gt; 'John'，注意这里不是 "John Resig"</span></span><br></pre></td></tr></table></figure>
<p>如下是一个利用前瞻实现手机号格式化的小函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 手机号分隔</span></span><br><span class="line"><span class="comment"> * 13522722724 -&gt; 135 2272 2724</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">separateMobile</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = ( <span class="string">'0'</span> + num ).replace(<span class="regexp">/(\d&#123;4&#125;)(?=\d)/g</span>,<span class="string">"$1 "</span>).split(<span class="string">''</span>)</span><br><span class="line">    arr.shift()</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　</p>
]]></content>
      <categories>
        <category>编程笔记</category>
      </categories>
  </entry>
  <entry>
    <title>随感-2 省游泳比赛</title>
    <url>/2017/11/02/swim/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="省游泳比赛"><a href="#省游泳比赛" class="headerlink" title="省游泳比赛"></a>省游泳比赛</h2><p><a href="http://www.sustc.edu.cn/news_events_/4322" target="_blank" rel="noopener">我校学生游泳队参加省大学生游泳锦标赛获佳绩</a></p>
<p>这则是放在校官网上的推送。</p>
<p>小时候被父母拉去学游泳，觉得看着游得还行就练到初二或初三，慢慢喜欢上的这个运动。这算是我第一次参加省的比赛吧。这次拿个200米混合泳第七，感觉很满意。要是来年还有机会，我感觉一定还能游得更好，不知为啥之后的10.29号的100米蛙泳竟然比我在省锦标赛还快，我游1:24.08那就能拿个第七，是不是校运会的计时员不准我就不得而知了。</p>
<a id="more"></a>

<h2 id="比赛记录"><a href="#比赛记录" class="headerlink" title="比赛记录"></a>比赛记录</h2><table>
<thead>
<tr>
<th>比赛项目</th>
<th>用时</th>
<th>名次</th>
</tr>
</thead>
<tbody><tr>
<td>200米混合泳</td>
<td>3:08.41</td>
<td>7</td>
</tr>
<tr>
<td>4*100米自由泳接力</td>
<td>1:13.74 / 4:45.85</td>
<td>团体4</td>
</tr>
<tr>
<td>100米蛙泳</td>
<td>1:28.45</td>
<td>12</td>
</tr>
<tr>
<td>男女4*50米自由泳接力</td>
<td>31.46 / 2:31.27</td>
<td>团体9</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>随感</category>
      </categories>
  </entry>
  <entry>
    <title>Windows 下配置 TeXLive 和 VScode 的 $\LaTeX$ 环境</title>
    <url>/2018/07/18/texlive/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>快速部署 $\LaTeX$ 环境。</p>
<a id="more"></a>

<h1 id="安装-TeXLive"><a href="#安装-TeXLive" class="headerlink" title="安装 TeXLive"></a>安装 TeXLive</h1><p>首先要安装 TeXLive ，推荐下载 TeXLive 的 ISO 镜像，因为在线安装下载过程会很慢。<br>境内教育网镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">华中科大：http:&#x2F;&#x2F;mirror.hust.edu.cn&#x2F;CTAN&#x2F;systems&#x2F;texlive&#x2F;Images&#x2F;texlive2018.iso</span><br><span class="line">清华：https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;CTAN&#x2F;systems&#x2F;texlive&#x2F;Images&#x2F;texlive2018.iso</span><br><span class="line">中科大：https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;CTAN&#x2F;systems&#x2F;texlive&#x2F;Images&#x2F;texlive2018.iso</span><br></pre></td></tr></table></figure>

<p>下载完成后，挂载镜像，执行 <code>install-tl-advanced.bat</code> 开始安装。安装除了路径自定义以外，其他默认即可。</p>
<p>安装完确认，环境变量已经配置好。在高级系统设置的环境变量页面中，系统变量里面找到 <code>PATH</code>，并在末尾添加“<code>C:\texlive\bin\win32</code>”（在本例中路径为 <code>C:\texlive\</code> ，请根据实际情况自行更换路径。效果以打开命令提示符，能正常执行 <code>latex</code> 命令为准。</p>
<h1 id="配置-VScode"><a href="#配置-VScode" class="headerlink" title="配置 VScode"></a>配置 VScode</h1><ol>
<li><p>安装 LaTeX Workshop 插件</p>
</li>
<li><p>在 Perferences -&gt; Settings 里面添加 <code>xelatex</code> 编译语句</p>
 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"latex-workshop.latex.recipes"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">            <span class="attr">"tools"</span>: [</span><br><span class="line">            <span class="string">"xelatex"</span></span><br><span class="line">                        ]</span><br><span class="line">                &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">            <span class="attr">"tools"</span>: [</span><br><span class="line">                <span class="string">"latexmk"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"pdflatex -&gt; bibtex -&gt; pdflatex*2"</span>,</span><br><span class="line">            <span class="attr">"tools"</span>: [</span><br><span class="line">                <span class="string">"pdflatex"</span>,</span><br><span class="line">                <span class="string">"bibtex"</span>,</span><br><span class="line">                <span class="string">"pdflatex"</span>,</span><br><span class="line">                <span class="string">"pdflatex"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"latex-workshop.latex.tools"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">            <span class="string">"-synctex=1"</span>,</span><br><span class="line">            <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">            <span class="string">"-file-line-error"</span>,</span><br><span class="line">            <span class="string">"%DOC%"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">"-synctex=1"</span>,</span><br><span class="line">                <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">                <span class="string">"-file-line-error"</span>,</span><br><span class="line">                <span class="string">"-pdf"</span>,</span><br><span class="line">                <span class="string">"%DOC%"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"pdflatex"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"pdflatex"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">"-synctex=1"</span>,</span><br><span class="line">                <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">                <span class="string">"-file-line-error"</span>,</span><br><span class="line">                <span class="string">"%DOC%"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"bibtex"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"bibtex"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">"%DOCFILE%"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设置完成，即可使用。</p>
</li>
</ol>
<p><code>ctrl + s</code> 保存后 VScode 自动编译，右侧可以显示 pdf 非常方便。</p>
<p><strong>更多快捷键可以 <code>F1</code> 查看。</strong></p>
]]></content>
      <categories>
        <category>计算机拾遗</category>
      </categories>
  </entry>
  <entry>
    <title>游记-哈尔滨-绥化-北京</title>
    <url>/2018/01/30/travelogue-HAERBIN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="出发-第零天，1-21"><a href="#出发-第零天，1-21" class="headerlink" title="出发-第零天，1.21"></a>出发-第零天，1.21</h1><p>Z108前往北京。</p>
<p>25T车厢挺新的，但是行李架比以前小了好多。</p>
<a id="more"></a>

<h1 id="出发中转-北京，1-22"><a href="#出发中转-北京，1-22" class="headerlink" title="出发中转-北京，1.22"></a>出发中转-北京，1.22</h1><p>午后到达北京，小队有岩松和成杰，成杰他严格意义上来说没到北京玩过。所以一起天安门广场上，感受下中国的政治中心。故宫，天安门，两旁的国博和人民大会堂，还有毛主席纪念堂。之后就去了隔壁的王府井逛了下，入夜了起风了就有些冷了，我就套一件带绒的拉链带帽卫衣实在是冻的不行，这才是零下几度，想起明天在哈尔滨可是-30°，就要做好充足准备。</p>
<p>在KFC缓缓，吹吹暖气，等晚上的车前往哈尔滨。晚上坐的是软卧，一晚上就到了，中间完全不停，体验非常好。</p>
<h1 id="第一天-哈尔滨，1-23"><a href="#第一天-哈尔滨，1-23" class="headerlink" title="第一天-哈尔滨，1.23"></a>第一天-哈尔滨，1.23</h1><p>早上到了哈尔滨，一下车，就感受到-30°冷风的威力，吹的脸直生疼。之后直接前往房东家。这儿公车都是1元全程，空调（暖气）车贵些2元。地上的积雪如果没扫或者没撒融雪剂大概有15cm厚。冷暖空气对流的地方会成霜，那就是冷风侵入的地方，要是窗户密闭不好就尤其明显。因为冰雪的缘故路面坑坑洼洼地，就像南方梅雨季节完的路面一样，现在哈尔滨路面经常是碎石，污雪遍地。同行的人有些装备还不齐就到民宿旁边的透龙批发市场采购，里面全是适合在东北穿的衣服，店家们都说今年的冬天是这几年来最冷的一次。我还有些高兴，毕竟此行的目的是体验中国不一样的气候与风土人情。我买个耳包挺配我的帽子的。透龙旁边就是索菲亚教堂，一种俄式风格。比我想象中的小，印象中是更宏伟的建筑。里面是建筑艺术博物馆，因为时间原因就没有去了，门票15元也不算贵。</p>
<p>中午在东方饺子王吃的，一家连锁餐馆。北方水饺种类多，一般的吃法蘸蒜醋，喜辣可以加一点油辣椒。我觉得熏肠不错，味道不重，肥油的量刚好，口感滑溜，配合蒜醋不会觉得腻。</p>
<p>下午逛了中央大街，街上有不少俄国商品店，我买了2盒熏鱼?9?8，也不知道好不好吃。哈尔滨气温稳定地保持在-30°左右，足以保存冰雕结构完整，大街上有各个企业赞助搭建的冰雕，一配合冰城风景，二又起到了宣传效果。到了哈尔滨就得吃特产马迭尔雪糕，这儿雪糕完全可以放在室外买，完全不用担心化。吃雪糕也是也是同样的。我还吃了烤红肠，红肠里面的填充肉粒更大肥瘦都有，吃起来更有趣。</p>
<p>哈尔滨下午4点半就入夜了，纬度高入夜早，况且现在是冬季，太阳一下山，加上大风，热量很快就从身上流失，所以来东北最重要是防风。中央大街走到头就是哈尔滨防洪纪念塔，纪念1957年成功战胜特大洪水设立的。</p>
<p><img data-src="/images/0123_1.jpg" alt="纪念塔"></p>
<p>纪念塔下面是松花江，现在江面已经冰封的严实，汽车可以开上去。傍晚江上风不小，甚至能感觉到温度一点点下降。对面太阳岛是我们明天游玩的地方。东侧是滨洲铁路桥（老江桥），原来继续北上到齐齐哈尔就是走这里，由于桥是上个世纪修建的，运能早就不能满足现在要求，现在大部分北上的车由哈东站承担，走滨北松花江公铁两用桥北上。</p>
<p>晚餐在<a href="http://www.dianping.com/shop/77275077" target="_blank" rel="noopener">92°俄式厨房</a>，一家店面挺小，人也不多，但是环境很棒的一间餐厅，料理也好吃，人均在100左右。餐前甜点鱼子沙拉，主食红菜汤配面包，烤肉饼，罐牛，炸薯条，奶汁杂拌，奶汁鲈鱼。分量刚好，4个人能吃饱。其中我最喜欢的是罐牛，沙拉，奶汁鲈鱼。罐牛酸甜口感，牛肉牛腩软糯，汤汁沁入到了肉里。沙拉开胃，奶汁鲈鱼虽然这个鱼头摆放有点仰望星空派的感觉，但是口感上佳，盘子最外面一圈薯泥，盘底铺上土豆片避免粘盘，鲈鱼切片去骨，铺在其上，配合芝士焗烤，奶香就进到肉里了。晚饭之后有点冷了，坐公车回去，今天的活动就告一段落。</p>
<h1 id="第二天-哈尔滨，1-24"><a href="#第二天-哈尔滨，1-24" class="headerlink" title="第二天-哈尔滨，1.24"></a>第二天-哈尔滨，1.24</h1><h2 id="冰雪大世界"><a href="#冰雪大世界" class="headerlink" title="冰雪大世界"></a>冰雪大世界</h2><p>昨晚虽然回去的不算晚，但是能量消耗比南方旅游来说是更大的。不说背包、行李的重量，单是身上穿的衣物增加了好几斤重量。寒冷天身体需要不停产热，即便有羽绒保暖，那也是挺累的。</p>
<p>为了看大世界的夜景我们特地晚一点到达，从下午4点玩到晚上9点半。中午在透龙和中央大街又加了点装备，尝试了下据说做锅包肉最地道的“<a href="http://www.dianping.com/shop/23896144" target="_blank" rel="noopener">老厨家</a>”，好吃不贵就是人有些多。中午高峰期大概需要等待1h。</p>
<p>这天听说还是几天来哈尔滨最冷的一天，同时冰雪大世界又是景区最冷的地方，平均气温-35°，我的手机冻关机好几次，从内衣里拿出来使用10分钟就因为寒冷电压不足自动关机，要连着充电宝保持电压，还有数据线也冻着像根棍子。</p>
<p>大世界夜景很美，照片放在了<a href="https://www.instagram.com/lizi_arthur/" target="_blank" rel="noopener"><strong>instagram</strong></a>上，读者可以点击移步看看。</p>
<p>晚上还是在中央大街吃的，<a href="http://www.dianping.com/shop/69491780" target="_blank" rel="noopener">辣莊重庆老火锅</a>虽然在这里吃“重庆”火锅怪怪的，但是为了暖暖冻了好几个小时的身子，补上晚饭就随便应付下，味道也还不错。</p>
<h1 id="第三天-哈尔滨，绥化，1-25"><a href="#第三天-哈尔滨，绥化，1-25" class="headerlink" title="第三天-哈尔滨，绥化，1.25"></a>第三天-哈尔滨，绥化，1.25</h1><p>上午退了房，还是在中央大街，尝试<a href="http://www.dianping.com/shop/9261442" target="_blank" rel="noopener">朝鲜风味馆</a>，下午就自行活动，我在哈工大，哈工程溜达。这晚上冷的狗屎都冻成硬的了，踢到吓一跳。</p>
<p>晚上坐火车前往绥化。</p>
<p>绥化是个小城市，生活节奏很慢，市区里面有基本的公交，但是这冬天太冷了，人们不太愿意等车，于是的士发展得还很不错。</p>
<h1 id="绥化，1-26-1-28"><a href="#绥化，1-26-1-28" class="headerlink" title="绥化，1.26-1.28"></a>绥化，1.26-1.28</h1><p>前面说了，绥化的节奏很慢。早上9点多才起，吃过早餐快10点，岩松姥姥姥爷十分热情，早餐做得像午餐一样，分量特别大，吃完到了中午都不会觉得饿。</p>
<p>一天下来几乎是老大爷的生活：上午<a href="http://www.dianping.com/shop/13272113" target="_blank" rel="noopener">泡澡-按摩-拔罐</a>，下午咖啡厅热饮暖暖身，晚上吃<a href="http://www.dianping.com/shop/58890387" target="_blank" rel="noopener">顾家电烤</a>，“娱乐中心”唱唱歌，睡前唠唠嗑听听故事。</p>
<p>晚上烧烤很不错，生熟刚好，口感极佳，被岩松称为板（niu）筋（bian）弹性十足。石蛋这家没做，是另一种东北特色零食，过一天我在市中心的路边吃到了。</p>
<p>四十一场，原来是个木材综合加工厂，网上查到大概是重整，土地重新规划。厂区靠近绥化站，离市中心很近。我们去到那边的时候，基本上是待拆迁状态，房子已经没有人住了，但是还没长满荒草，也许是气候不宜。冬天的积雪将街道裹了起来，木材，设备留着积雪。在向东走些就是田地了，铺满雪的样子尤其让南方兴奋，比如：在雪地里打滚。</p>
<p><img data-src="/images/0123_4.jpg" alt="厂房"></p>
<p><img data-src="/images/0123_3.jpg" alt="齿轮"></p>
<p><img data-src="/images/0123_2.jpeg" alt="窗户"></p>
<p><img data-src="/images/0123_5.jpg" alt="田地"></p>
<p>晚上在<a href="http://www.dianping.com/shop/10362634" target="_blank" rel="noopener">老渔翁笨锅炖</a>吃的，算是在东北之旅最后一个正式的晚餐。</p>
<h1 id="第七天，回程中转-北京，1-29"><a href="#第七天，回程中转-北京，1-29" class="headerlink" title="第七天，回程中转-北京，1.29"></a>第七天，回程中转-北京，1.29</h1><p>火车开进北京的时候，就能感觉到一股党的春风入面，仿佛气温没有那么冷了，溜到北京西的铁道两旁巨幅墙报，展示了习近平新时代中国特色社会主义思想，党十九大的精神。我们深受鼓舞。为了进一步学习精神，我们决定下车后，去最近的庆丰包子铺，点份“<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%B8%AD%E5%A5%97%E9%A4%90/12767721" target="_blank" rel="noopener">主席套餐</a>”，体会习主席与人民的鱼水情深。</p>
<p>中午逛了天坛公园，弥补我去年时间匆忙导致的遗憾。</p>
<p><img data-src="/images/0123_6.jpg" alt="天坛"></p>
<p>还有宏源南门涮肉，也是上次在什刹海那家没排得上队，这次也补上了，简直开心。</p>
<h1 id="旅行照片"><a href="#旅行照片" class="headerlink" title="旅行照片"></a>旅行照片</h1><ul>
<li><a href="https://www.instagram.com/lizi_arthur/" target="_blank" rel="noopener"><strong>instagram</strong></a></li>
</ul>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
  </entry>
  <entry>
    <title>游记-日本</title>
    <url>/2019/07/10/travelogue-JAPAN/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这次旅行基本上没提前多久准备，递交签证的同时就着手准备各类事项，签证到手3天后就出发。大致计划是尽量深度游览关西，如果能照顾到东京就可以去一下。</p>
<a id="more"></a>

<h1 id="准备签证"><a href="#准备签证" class="headerlink" title="准备签证"></a>准备签证</h1><p>根据所在地区，在淘宝上选择销量较高的旅行社，进行代理送签至领事馆。日签出签率一般都挺高，有的代理店家甚至提供出签保险，在这种情况下就可以买飞机票了。如果代理店家不提供保障，携程和飞猪也可以提供签证险（出签失败，全退飞机票钱）。</p>
<h1 id="安排住宿"><a href="#安排住宿" class="headerlink" title="安排住宿"></a>安排住宿</h1><p>在出签就可以尽快订酒店了，酒店一般推荐通过Booking，Agoda，Airbnb预定。VISA / Mastercard 通常会有联动酒店代理平台打折活动，下单的时候注意通过信用卡渠道的推广链接。</p>
<h1 id="准备至少2张银行卡"><a href="#准备至少2张银行卡" class="headerlink" title="准备至少2张银行卡"></a>准备至少2张银行卡</h1><ul>
<li>一张银联储蓄卡，方便ATM取现金应急。</li>
<li>一张非银联信用卡，不少店不支持银联，况且办一张可以返现的VISA / Mastercard / JCB 也是不错的选择。JR在线订票不支持银联。</li>
</ul>
<h1 id="出行必备"><a href="#出行必备" class="headerlink" title="出行必备"></a>出行必备</h1><ul>
<li><p>数据流量：不管是移动Wi-Fi，还是境外流量卡，至少要选择一种网络接入方式，没有网络就很麻烦。不建议国内电话卡直接进行数据漫游，因为按照国际惯例，漫游数据回归属地，所以即便国内手机卡在境外漫游也无法使用谷歌地图。</p>
</li>
<li><p>大众点评：竟然还能用，配合谷歌地图很不错。</p>
</li>
<li><p>谷歌地图：公交时刻和线路非常准确，有价格提示，但是公交站定位不太准确，需要随机应变地找，电车时刻没有乘换案内全面，但是还能用。</p>
</li>
<li><p>乘换案内：Yahoo 出品，电车和火车时刻信息非常准确，有价格提示，公交线路信息不太全。</p>
</li>
</ul>
<p>注意：不建议使用百度地图，没有价格提示，结果也很不明确，且少；高德地图好像根本没法使用。</p>
<ul>
<li>谷歌翻译：手机翻译就靠它，可以手写输入，可以拍照翻译。</li>
</ul>
<p>其次，除非会日语，否则按照日本路人平均英语水平，还是交流还是比较困难，需要使用国际通用手势。案内所（询问处）的工作人员的外语水平相对会高。</p>
<ul>
<li>Skype（可选）：网络电话，可以设置被叫来电显示，被叫者不可回拨到Skype，拨打主叫胜在便宜，价格和国内手机资费相同约0.14元每分钟。</li>
</ul>
<h1 id="简要行程及【移动方式】"><a href="#简要行程及【移动方式】" class="headerlink" title="简要行程及【移动方式】"></a>简要行程及【移动方式】</h1><ol>
<li>深圳-名古屋【春秋航空】</li>
<li>名古屋-京都【JR新快速（JR东海道本线/JR琵琶湖线）】</li>
<li>京都-奈良-京都【近铁】</li>
<li>京都-大阪【JR新快速（JR京都线）】</li>
<li>大阪-东京【全日空（星悦航空实际承运）】</li>
<li>东京-名古屋【JR新干线】</li>
<li>名古屋-深圳【春秋航空】 </li>
</ol>
<h1 id="详细行程"><a href="#详细行程" class="headerlink" title="详细行程"></a>详细行程</h1><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><div align=center><img data-src="/images/jp/image1.png" style="max-width:50%" /></div>

<p>根据我们的所在地，广深港地区到关西和中部地区的直飞往返航班中只有春秋最便宜，虽然春秋被调侃为航空硬座，但是极致的性价比还是选择了它。回程建议根据需求加订行李额度，以防止超重。</p>
<p>到达名古屋站差不多12点了，这个点名古屋站所有投币式储物柜几乎都满了，包括附近高岛屋的客服中心，所以我们也没地方存行李。随便在车站找了家店吃了拉面，拉着行李箱就开始接下来行程。</p>
<p>第一站直接去丰田产业技术纪念馆，离名古屋站比较近，几站电车。主要介绍丰田如何从纺织发家，开始做汽车的故事。场馆内几乎所有纺织机，组装机械都能运行。亲手按下Start按钮听到机器轰鸣，对于小孩子或者理工男有着特别的吸引力。</p>
<div align=center><img data-src="/images/jp/image2.jpeg" style="max-width:50%" /></div>

<p>纺织机</p>
<div align=center><img data-src="/images/jp/image3.jpeg" style="max-width:50%" /></div>

<p>5速手动变速箱</p>
<p>下一站是名古屋城，1945年美军空袭名古屋，名古屋城的本丸御殿、大天守、小天守、东北隅橹、正门、金𩾇被烧毁。所以目前大部分是二战后的根据原来测量和设计的重建建筑。我们参观的时候，名古屋城天守阁在整修没法上，不过本丸御殿2019/6/8整体重建完成，刚好赶上，由于本丸御殿重建过程中并没有进行做旧操作，其实给人的历史感并不是很强烈，主要体验的是日式的风格。</p>
<div align=center><img data-src="/images/jp/image4.jpeg" style="max-width:50%" /></div>

<p>修整中的名古屋城天守阁，二战后使用混凝土重修，内部增加电梯，二战后也过去半个多世纪，官网介绍应该是打算重新翻新，进行木造复原工程，即混凝土改木建。可能不太能看得清楚，屋顶的的吻兽便是金鯱。</p>
<div align=center><img data-src="/images/jp/image5.jpeg" style="max-width:50%" /></div>

<p>金鯱</p>
<p>晚上乘坐新快速到达京都，新快速比新干线便宜一半，但慢一倍且需要转车，由于晚间没有景点，我们也觉得慢一点无所谓，刚好在电车上休息。</p>
<div align=center><img data-src="/images/jp/image6.jpeg" style="max-width:50%" /></div>

<h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><div align=center><img data-src="/images/jp/image7.jpeg" style="max-width:50%" /></div>

<p>来的时候做了一点功课，快速预习一下《艺妓回忆录》，里面小千代在连绵的桔色千本鸟居下奔跑的场景取自伏见稻荷大社。顺便提下，这部电影的女演阵容非常强大，有章子怡，杨紫琼，巩俐。稻荷神主管农业和商业，伏见稻荷大社又是千万稻荷社的总社，所以这里香火旺盛。在动漫中，常常出现的日式狐狸是稻荷神的使者。</p>
<div align=center><img data-src="/images/jp/image8.jpeg" style="max-width:50%" /></div>

<p>进门走不久，就能看到几个竹签桶，便是求签（籤，fortune stick）。许下愿望，充分混合签筒，倒出一个写有数字的竹签，把竹签交给神社里的巫女和100円便会给你对应的签纸。一般来说如果是吉签建议带回家，意为将好运带回家，凶签折起系在神社指定位置，拜托神仙祛除厄运。不过凶签一样可以带回家，毕竟签诗的内容可以随时提醒自己，作为反省的警示。</p>
<div align=center><img data-src="/images/jp/image9.jpeg" style="max-width:50%" /></div>

<p>我抽的神签</p>
<p>逛完前面的建筑，经过一个较大的鸟居，就进入稻荷山，后面就是“神灵”住的地方，小路被连绵的鸟居覆盖。鸟居一般正面两侧写着纳奉，后面两侧注明身份和日期。这一点和国内的寺庙是类似的，寺庙帮助信徒祈福。后面我们还看到其他寺庙有类似的设计：浅草寺那个标志性写着雷门的大灯笼后面就能看到署名，松下幸之助给浅草寺捐款重修雷门；春日大社门口参道两旁一样连绵的石灯笼。</p>
<div align=center><img data-src="/images/jp/image10.jpeg" style="max-width:50%" /></div>

<p>鸟居中</p>
<p>由于时间关系，我们并没逛完整个稻荷山，逛到半山腰就前往下一个景点，三十三间堂。</p>
<p>三十三间堂，迎面间数也称开间有三十三间，以此得名。殿内有1001座千手观音的木像。两旁有28座风、雷等神的立像。虽然千手观音样式相同，但是每尊由于不同工匠的手工差异，有着个体区别，千尊排开觉得十分震撼。这让我想起，重庆罗汉寺中罗汉堂500多尊形态各异的罗汉，各有精彩。本堂成长方形，长边特别长，所以传统上还用来做远程射箭比赛。</p>
<p>浏览完，沿着鸭川向北，去锦市场附近吃饭，锦市场附近有许多景点，祇园，八坂神社，清水寺，法观寺。我们由于时间或景点问题，这附近的景点都没去。注意清水寺的标志建筑清水寺舞台得等到2020年日本奥运前才修理完成，所以最近是不建议前往清水寺。</p>
<p>沿着鸭川再向北来到下鸭神社准确来说叫贺茂御祖神社，鸭川三角洲西边为贺茂川、东边高野川，中间的交会点称为鸭川三角洲，交会点以南才叫鸭川。下鸭神社就位于三角洲附近。</p>
<p>经典路线是下鸭神社，河合神社，相生社，糺（音同纠）之森，一路逛下来就会到鸭川三角洲，可以踏水玩耍。相生社虽然很小，但是据说是京都祈求良缘最灵验的地方。</p>
<div align=center><img data-src="/images/jp/image11.jpeg" style="max-width:50%" /></div>

<p>相生社</p>
<div align=center><img data-src="/images/jp/image12.jpeg" style="max-width:50%" /></div>

<p>鸭川三角洲</p>
<h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p>从京都前往奈良建议使用近铁一日通，包含京都到奈良的往返电车票和奈良地区的公交，如果另外要坐京都市营地铁可以购买斑鸠卡（京都版）替代。在京都站的近铁客服咨询处可以购买近铁一日通，需要出示护照。</p>
<p>人教社初中历史课本上应该都学习过鉴真东渡的故事，既然来了奈良就一定要来看一下。中国唐朝对应日本相同时期是奈良时代，都城平城京位于奈良，仿照唐长安城进行建造【拓展阅读：唐招提寺金堂和中国唐代的建筑-梁思成】。这时刚好是夏日莲花开放的季节，唐招提寺开放了专门培养各个品种的莲花的庭院，本土的，中国的，形态各异。</p>
<div align=center><img data-src="/images/jp/image13.jpeg" style="max-width:50%" /></div>

<p>在唐招提寺的北面有个小佛堂放着鉴真大师的木造金身坐像，往东北角走便是鉴真大师的墓，有意思的是在鉴真大师墓旁有一块比较突兀的石碑上面写着“赵朴初居士之碑”，好像和周围环境并不协调。赵朴初先生生前是国家政协副主席，民进中央名誉主席、中国佛教协会会长。1962年11月，赵朴初先生与唐招提寺森本长老一起倡议中日佛教共同纪念鉴真和尚逝世1200周年，中日邦交正常化之前，促成鉴真和尚像回国扬州大明寺探亲。赵朴初先生就致力于中日友好交流事业，立此碑纪念。上面提到的梁思成的文章原刊载于1963年《鉴真纪念集》。</p>
<div align=center><img data-src="/images/jp/image14.png" style="max-width:50%" /></div>

<p>中国大明寺鉴真学院的题字</p>
<div align=center><img data-src="/images/jp/image15.jpeg" style="max-width:50%" /></div>

<p>近铁奈良站附近有一条步行街，吃饭可以在这解决。来了奈良，那必定是要来看鹿了，奈良公园附近散养了许多鹿，东边的二月堂南边的春日大社，西边的兴福寺，北边的东大寺，片区内都能看到自由歇息，向游客要鹿仙贝的鹿鹿。喂鹿只能用路边统一售卖的鹿仙贝，150円一包，自己准备食物可能会伤害鹿的健康。此外不知道是不是鹿仙贝，即便鹿散养，到处拉屎，公园的味道没有被鹿的排泄物熏得很臭，只是不太雅观。线路一般推荐从春日大社，东大寺，二月堂，如果时间够还可去门口的兴福寺，还有远离市区的法隆寺。兴福寺我们不太推荐，性价比不高。法隆寺，由于时间问题就没有去，但是看到网上评价很不错，算是一个遗憾吧。二月堂位处地势高点，可以俯瞰公园，要是刚好是傍晚的时候，看日落很不错。</p>
<div align=center><img data-src="/images/jp/image16.jpeg" style="max-width:50%" /></div>

<p>唐招提寺金堂</p>
<div align=center><img data-src="/images/jp/image17.jpeg" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image18.jpeg" style="max-width:50%" /></div>

<p>春日社参道</p>
<div align=center><img data-src="/images/jp/image19.jpeg" style="max-width:50%" /></div>

<p>二月堂</p>
<h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><p>东京皇居，京都御所，仙洞御所，桂离宫，修学院离宫，这几个皇家景点受宫内省管辖，除了京都御所都要在网上进行预约才能进入。东京皇居是其中最热门的，一般每月初会开放下个月的预约。后面4个都在京都地区，相对没有那么热门。第四天的行程相对休闲。我们最后选择了在京都市内的2个景点（京都御所、仙洞御所）。</p>
<p>需要预约的景点均免费，提供中文解说播放器，游览时都会有宫内警察跟着，同时一定配有日本本地导游，不可以随便乱走，只能走指定线路。</p>
<div align=center><img data-src="/images/jp/image20.jpeg" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image21.jpeg" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image22.jpeg" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image23.jpeg" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image24.jpeg" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image25.jpeg" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image26.jpeg" style="max-width:50%" /></div>

<p>醒花亭，取自李白诗 “夜来月下卧醒,花影零乱,满人襟袖,疑如濯魄于冰壶。”</p>
<div align=center><img data-src="/images/jp/image27.jpeg" style="max-width:50%" /></div>

<p>上图均为仙洞御所内</p>
<p>这天中午犯了比较大的错误，没弄清楚要去的餐厅具体大小，是否需要订位，导致走了许久，好像御所这边吃的不太多，最后大中午的往南走了2公里去锦市场附近吃的。</p>
<p>南禅寺，我觉得可能秋天来这边拍照会更加好看，夏天的趣味估计是看看罗马式水道，听着流水声还能感觉到点清凉吧。多天的日均3W步数的高强度徒步旅游，有点累了，晚间前往河原町附近购物。</p>
<div align=center><img data-src="/images/jp/image28.jpeg" style="max-width:50%" /></div>

<p>南禅寺</p>
<h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><p>第五天还有个小插曲，因为4天后是G20峰会，关西地区重要交通换乘中心的Coin Locker逐渐暂停运营以确保安全，导致差点存不上行李。</p>
<p>嵯峨野游览小火车，各方向都是半小时一班，旺季如果不提前订票可能没有票，网上提前在JR西日本官网订票比较稳，但是需要信用卡（不支持银联），出行前尽量前到JR西日本售票窗口（绿色窗口）取票，如果直接到龟冈取票，人可能会比较多。推荐的是龟冈至岚山区间，岚山方向建议选择偶数座位，靠近山谷（保津川）。春天的樱花、夏天的新绿、秋天的红叶是这边的特色。除了小火车，水路有保津川漂流，看起来也很不错。</p>
<div align=center><img data-src="/images/jp/image29.png" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image30.jpeg" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image31.jpeg" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image32.jpeg" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image33.jpeg" style="max-width:50%" /></div>

<p>出了岚山站，顺着路标就到嵯峨野竹林。如果对头发有任何困扰的朋友，可以来御髪神社看一看，也是出岚山站几步路。嵯峨野竹林是李安拍摄《卧虎藏龙》的取景地，既然提到这个电影，那又和上面提到的《艺妓回忆录》中2位演员有关系了，杨紫琼和章子怡，此片获得奥斯卡最佳影片提名。</p>
<div align=center><img data-src="/images/jp/image35.jpeg" style="max-width:50%" /></div>

<p>参天竹林</p>
<div align=center><img data-src="/images/jp/image36.jpeg" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image37.jpeg" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image38.jpeg" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image34.jpeg" style="max-width:50%" /></div>

<p>离开竹林就到天龙寺，这是我非常喜欢的一个庭院，日式风格中还有大气，花园各色的紫阳花开放着，也适合拍照。</p>
<p>如果是樱花或者红叶的季节可以到渡月桥上再看看桂川两侧的风景，我们接下来就去京都的标志性景点金阁寺，而且这个是旅游团必去景点，总的来说体验比较普通。</p>
<div align=center><img data-src="/images/jp/image39.jpeg" style="max-width:50%" /></div>

<p>金阁寺</p>
<div align=center><img data-src="/images/jp/image40.jpeg" style="max-width:50%" /></div>

<p>船形松</p>
<div align=center><img data-src="/images/jp/image41.jpeg" style="max-width:50%" /></div>

<p>北野天满宫，离金阁寺很近，作为学生自然要拜拜日本的学问之神，所以便来了。北野天满宫并不大，主要是过来打个卡。</p>
<h2 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h2><div align=center><img data-src="/images/jp/image42.jpeg" style="max-width:50%" /></div>

<p>大阪景点并不太多，本来传统景点计划了大阪城公园（天守阁），四天王寺，但是和沟通家人觉得前面逛了太多的传统景点，如果不是特别有意思便不想去了。大阪便只剩下2处现代景点，大阪海游馆或者大阪环球影城，选了前者。建议在地铁站内的站长室购买OSAKA海游票（大阪市内版）包含当天市内市营地铁和公交相当划算，不用到了场馆在排队。我之前去过温哥华水族馆（Vancouver Aquarium），和之相比，大阪海游馆确实有点小，标牌没有中文解释也不是很友好。主要结构就是围绕中心巨大的水槽，周围的小水槽对环太平洋的生物进行介绍。写游记的时候查过资料才发现，全球拥有全球最大水槽的水族馆竟然在珠海长隆，日本最大的位于冲绳，美国最大的位于亚特兰大。关于海洋生物我了解的并不多，所以没有更多的介绍了。无论是动物园还是水族馆，除了为了营收，更多吸引人或者说提升整个机构核心竞争力，一是欢乐，二是教育，三是保育。</p>
<div align=center><img data-src="/images/jp/image43.jpeg" style="max-width:50%" /></div>

<p>鲸鲨</p>
<div align=center><img data-src="/images/jp/image44.jpeg" style="max-width:50%" /></div>

<p>下午至晚间便是购物环节，心斋桥，道顿堀，难波站，一片都是观光购物的。</p>
<h2 id="第七天"><a href="#第七天" class="headerlink" title="第七天"></a>第七天</h2><p>购物和转机的一天。</p>
<p>大阪附近有2个机场，伊丹机场和关西机场，伊丹偏国内航线，关西偏国际航线。由于关西机场距离一个地铁站有个奥特莱斯（临空城Rinku Premium Outlets），便选择这边前往东京。东京也有2个机场，羽田和成田，成田更远离市区车费和时间上不太划算，所以一般建议飞羽田。一般提前订票日本国内航线会比新干线便宜，折扣幅度可达一半，如果不确定行程或者距离较近还是建议新干线。</p>
<p>对于新干线，还想省钱的方式是去大车站旁的金券行或者是代理商的自动售卖机，不同店铺价格不同，需要多比较。他们一般出售的是回数券，也就是次票，自由席的回数券直接就可以进站乘车，指定席的需要到车站内机器上选座才能使用。一般从JR官方渠道买11张回数券只收10张的钱，代理商通过将回收市面上的回数券或是直接购买热门线路的回数券将其拆开来卖来盈利。我们从东京回名古屋的新干线便是购买的回数券，要注意的是自由席一般只占有一列列车的小部分车厢可能会没有位置，所以如果指定席和自由席差价不太多的建议选择指定席更安全，而且错过指定席的列车没关系，可以自动换乘当天的自由席列车。</p>
<h2 id="第八天"><a href="#第八天" class="headerlink" title="第八天"></a>第八天</h2><p>东京之旅快结束了，每到一个国家，照例是要到其博物馆看看的，在京都、奈良为了省时间都没去博物馆，然而东京国立博物馆是肯定不能错过的。看博物馆一般要注意的是开馆时间，常见的坑是周一闭馆；其次，关于特展最好事先查阅资料，了解规模和价格，避免抱有过高期望专程前往。</p>
<p>上野公园内有不少景点，上野动物园，东京国立博物馆，国立科学馆，国立西洋美术馆，等等。鲁迅在《藤野先生》的第一段写道：“东京也无非是这样。上野的樱花烂熳的时节，望去确也像绯红的轻云……”，上野公园在春天也确实是赏樱花的好去处。上野公园内向东眺望能看到天空树，东京最高的建筑，东京3处常见的眺望处是天空树，东京塔，梅田大厦。</p>
<p>东京区域有非常多的博物馆，在旅游期间，全逛完肯定是不可能的。如果在东京逗留比较长时间的朋友，可以选择东京博物馆通票（Tokyo Museum Grutto Pass），包含东京大部分博物馆和动物园，水族馆，使用通票可以免费进入或者有一定折扣。</p>
<p>我们根据体力和时间只选了两个东京国立博物馆和国立西洋美术馆。如果时间够，还建议去靖国神社，了解日本人是如果理解二战。</p>
<div align=center><img data-src="/images/jp/image45.jpeg" style="max-width:50%" /></div>

<p>奈良大和四寺特展，多为佛造像，不可拍照所以没图</p>
<div align=center><img data-src="/images/jp/image46.jpeg" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image47.jpeg" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image48.jpeg" style="max-width:50%" /></div>

<p>日本刀的介绍</p>
<div align=center><img data-src="/images/jp/image49.jpeg" style="max-width:50%" /></div>

<p>明王，如来，菩萨在佛像中的区别。明王是七世纪左右在印度原有的印度教神衹的影响下诞生的佛教尊像。大多呈现忿怒相，以调伏众生中不听教化之人。如来指己经开悟、获得解脱的人。最初仅指获得开悟后创立佛教的古代印度的释迦牟尼，后来出现了阿弥陀如来、大日如来等众多如来。菩萨指为了获得开悟而精进修行的人。在以普度生为宗旨的大乘佛教中，将慈悲施予众生的行为就是修行。</p>
<div align=center><img data-src="/images/jp/image50.jpeg" style="max-width:50%" /></div>

<p>浮世绘代表作神奈川冲浪，原来是很小幅的作品。</p>
<div align=center><img data-src="/images/jp/image51.jpeg" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image52.jpeg" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image53.jpeg" style="max-width:50%" /></div>

<div align=center><img data-src="/images/jp/image54.jpeg" style="max-width:50%" /></div>

<p>除了主馆，还有东洋馆，里面收藏了大部分是中国，以及朝鲜、埃及等各地文物。</p>
<div align=center><img data-src="/images/jp/image55.jpeg" style="max-width:50%" /></div>

<p>图为大谷探险队进入3次进入西域的示意图。</p>
<p>国立西洋美术馆主要以松方幸次郎（川崎造船所，现在的川崎重工业的社长）为基础建立的，来这主要看莫奈、梵高、塞尚的印象派作品，甚至还有几幅毕加索的画。</p>
<div align=center><img data-src="/images/jp/image56.jpeg" style="max-width:50%" /></div>

<p>巴勃罗·毕加索，男与女</p>
<div align=center><img data-src="/images/jp/image57.jpeg" style="max-width:50%" /></div>

<p>保罗·塞尚, 蓬图瓦兹的桥与堤防</p>
<div align=center><img data-src="/images/jp/image58.jpeg" style="max-width:50%" /></div>

<p>克劳德·莫奈，塞纳河的早晨</p>
<h2 id="第九天"><a href="#第九天" class="headerlink" title="第九天"></a>第九天</h2><p>由于天气不太好，一直在下雨，而且是日本之行的最后一天，实在是累了，只去了浅草寺打卡，然后再东京站旁的银座逛了逛，就乘坐新干线返回名古屋，并从名古屋乘坐回国的飞机。这便是浅草寺标志性建筑雷门。</p>
<div align=center><img data-src="/images/jp/image59.jpeg" style="max-width:50%" /></div>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
  </entry>
  <entry>
    <title>游记-南京</title>
    <url>/2017/09/18/travelogue-NANJING/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>时值九月初，处暑已经过去一周，长江以北的天气开始转凉，刚好离开学还有一周多的时间，赶快抓住了假期的尾巴同父母出游一次。算上这一次，就还有东京汴梁没去，北京、西京、南京都游玩过了。</p>
<a id="more"></a>
<h1 id="出发-第零天"><a href="#出发-第零天" class="headerlink" title="出发-第零天"></a>出发-第零天</h1><p>到达时间是前一天晚上，我一直还担心飞机因为台风“玛娃”延误或者无法起飞，而且买了延误&amp;取消险，延误没达到赔偿时间，结果没派上用场，算是花钱买心安了。我们住在丹凤街上，下地铁前往酒店的时候，路过了南京第一批罗森店，前几天真的被<a href="http://www.thepaper.cn/newsDetail_forward_1787115" target="_blank" rel="noopener"><strong>网上</strong></a>疯传的排队相片吓到了，也许南京人被苏果垄断便利店埋怨已久了吧。</p>
<h1 id="第一天-钟山景区"><a href="#第一天-钟山景区" class="headerlink" title="第一天 钟山景区"></a>第一天 钟山景区</h1><p>酒店楼下有家馄饨，店面比较小，门口也不太干净，也许是刚到，还无法从装潢分辨本地的好吃与难吃，这家店只有一般的水平，做法比较大概是本地传统做法：紫菜馄饨，皮够薄，猪肉馅但是打的不够有弹性，说起来还是虾仁猪肉馄饨好吃，上次在香港会展中心往地铁站天桥下面的小店吃的最和心意，香港人舍得用料但是相对的价格就不便宜了，超量的味精尝试掩盖水平的不足，我草草把馄饨吃完没喝汤就离开了。之后我们乘地铁前往下马坊然后前往钟山景区。</p>
<p>先到的是中山陵，天空有点小雨落下，把青石润湿了，我穿的洞洞鞋更要当心滑到，走的慢点就看的详细些，道路两旁，种满了银杏树和松树。<br><img data-src="/images/0918_2.jpg" alt="银杏"></p>
<p>碑亭参观期间在修复，我们就径直登上阶梯，祭堂后面的3块光洁平整的花岗石感觉有些违和，猜测是特殊时期被磨光的，两侧却还留着，不过也许是重刻的，回来查资料确实是这样。<br><img data-src="/images/0918_1.jpg" alt="祭堂"></p>
<p>现在无法进入墓室，只能在祭堂里拜谒中山先生的坐像。第六层平台两侧安放着上海特别市政府为纪念奉安大典（1929）捐献的铜鼎一对，上刻“奉安大典”四个篆字，其中西侧的铜鼎在1937年12月的南京保卫战中被日军弹片击中，留下了两个弹孔。<br><img data-src="/images/0918_3.jpg" alt="弹孔"></p>
<p>正午时候，前往美龄宫。美龄宫有三层，九一八事件后，1931年蒋介石开始为宋美龄建造这座官邸，用来谒陵、礼拜和度假的别墅。建筑是中式风格，钢筋混凝土建造，这里的用途曾多次变化，现在是根据原来的记录复原的。相比之下，我觉得还是台北后来新建的士林官邸更宜居，这里感觉上有更多的肃穆的气息，有各种战时的特殊布置的痕迹。美龄宫建造最具特色的地方就是它的位置，周围围绕一圈梧桐树像一条项链，不同节气不同颜色的链带中间点缀上美龄宫的琉璃瓦，从远处的高空看上去，美丽极了。<br><img data-src="/images/0918_4.jpg" alt="美龄宫"></p>
<p>逛完美龄宫本来想先去吃午饭的，就在门口的南京大牌档（深圳当然也是有的，被LJW推荐过），奈何人实在太多，则返回接着游明孝陵。</p>
<p>明孝陵是明朝开国皇帝，明太祖朱元璋和其妻子马氏的陵墓。明朝后来的君主都葬在北京，组成明十三陵。也许读者都见过的是最出名的那副“神道”的图，是明孝陵中最出名的景点；<br><img data-src="/images/0918_8.jpg" alt="神道1"><br><img data-src="/images/0918_7.jpg" alt="神道2"><br>第二幅是在南京博物院里面的藏品。神道最好看的时候是秋天,银杏树叶变黄，铺到地上。</p>
<p>我们从东门——四方城进入<br><img data-src="/images/0918_6.jpg" alt="四方城"><br>里面摆放着神功圣德碑，屋顶是近些年为了保护加盖的，原来只残存四周墙壁。向里面走经过神道，登上宝城，绕到后方可以近距离看到明太祖的陵墓。</p>
<p><img data-src="/images/0918_5.jpg" alt="宝顶"><br>关于明太祖的陵墓有些传说，一是七天速葬，二是十三城门抬棺材。至于真假就由读者自己分辨了。</p>
<p>逛完这个算是可以吃午饭了，我们返回来的时候<a href="http://www.dianping.com/shop/6323471" target="_blank" rel="noopener">南京大牌档(中山陵店)</a>午市快收档了，菜式比较少，尝了汤包，古法糖芋苗，推荐虾黄豆腐，批评王府泡椒鸡实在偏甜，“泡椒”名不副实。</p>
<p>傍晚前往，亚洲最大的地铁站，南京第一商圈，新街口，吃吃喝喝，在此不记录了。</p>
<h1 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h1><p>第二天早上，尝到了昨天晚上没食到的尹式汤包，在酒店楼下向地铁站走没多远。现在想起味道，还有点甜甜的，不过味精不少，过会儿需要饮水。昨天在钟山景区逛了许久，今天就规划了些比较休闲的，瞻园，愚园，夫子庙，晚上游附近秦淮河。</p>
<p>这次旅行没计划顺道去苏州玩一趟，以经验而言，苏州园林的名气最大，不过依着苏州的南京，相比园林也不会太差。</p>
<p>瞻园，门口又一匾“金陵第一园”，第一印象就是大气。瞻园始建于明朝初年，是明太祖朱元璋称帝前的吴王府，因朱元璋御授该府与徐达而未受领，后以该府对面关帝庙为基敕建新府，广造园林，是中山王徐达的府邸花园。<br><img data-src="/images/0918_9.jpg" alt="瞻园"></p>
<p>这幅虎是瞻园一个特色文物，此一笔书就，寓意四字“富甲天下”。不知，读者能不能看出来。<br><img data-src="/images/0918_10.jpg" alt="虎"></p>
<p>愚园历史最早可追溯至明中山王徐达后裔徐傅的别业，至今已有六百多年的历史，后几经转手。清光绪二年，胡恩燮为奉养母亲，辞官筑园，取名愚园，既有表明其不仕归隐“自以为愚，更其名为愚园”，“以愚名者，乐山水而自晦于愚也”之心迹，又寓“大巧如拙，大智若愚”之意。设景三十六处；1915年，胡恩燮嗣子胡光国进行扩建，面积近3万平方米，增设三十四景，故有前后七十景之说，后历经战乱，园林几度损毁。现在的愚园是根据历史照片重建的，所以进门后给人那种历史的感觉不是那么明显。<br><img data-src="/images/0918_11.jpg" alt="养生池"></p>
<p>下午去了夫子庙，白鹭洲公园，秦淮河附近。到没有特别印象深刻的地方，只觉得是中规中矩的旅游区，顺便两岸的小食店有好吃的，也有特别难吃的，挑选的时候读者要擦亮眼睛和清理鼻子，不要问我是怎么知道的。<br><img data-src="/images/0918_12.jpg" alt="江南贡院"></p>
<p>晚上是在夫子庙地铁站附近的<a href="http://www.dianping.com/shop/91641460" target="_blank" rel="noopener">碉堡烤鱼(夫子庙店)</a>吃的烤鱼，第一天和第二天中午都是吃的南京菜，这下换下味道，让胃恢复下。</p>
<h1 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h1><p>总统府 - 鸡鸣寺</p>
<p>未完待续……<br>（真的要快点写。。记性太差）</p>
<h1 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h1><p>南京博物馆 -大屠杀纪念馆</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
  </entry>
  <entry>
    <title>Travis CI 构建 Hexo 自动部署</title>
    <url>/2018/07/09/travis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h1><p>CI是 Continuous Integration 的缩写，持续集成之意。</p>
<blockquote>
<p>持续集成是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>
</blockquote>
<p><img data-src="/images/Continuous.png" alt="CI"></p>
<h1 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h1><h2 id="Hexo-搭建"><a href="#Hexo-搭建" class="headerlink" title="Hexo 搭建"></a>Hexo 搭建</h2><p>这里使用<code>Hexo</code>+<code>Next</code>+<code>GitHub Pages</code>组合示范过程，具体过程不再赘述。网站源码放到src分支，博客的静态文件部署到master分支。</p>
<a id="more"></a>

<h2 id="设置-Travis-CI"><a href="#设置-Travis-CI" class="headerlink" title="设置 Travis CI"></a>设置 Travis CI</h2><p>登陆 <a href="https://travis-ci.com/" target="_blank" rel="noopener">Travis CI</a>，使用 GitHub 账户登录，它会自动关联 GitHub 上的仓库。点击右上角用户查看 GitHub 仓库，并选择要启动的项目，这里选择<code>yourname/yourname.github.io</code>。</p>
<p>点击设置按钮，进入设置选项，如下图开启相关服务。</p>
<p><img data-src="/images/ci1.png" alt="CI1"></p>
<h2 id="配置-Acess-Token"><a href="#配置-Acess-Token" class="headerlink" title="配置 Acess Token"></a>配置 Acess Token</h2><p><img data-src="/images/ci2.png" alt="CI2"></p>
<p>创建新的<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Github token</a>，勾选必要权限，起名随意，可叫（Travis-CI token）。必要权限如下。</p>
<p><img data-src="/images/ci3.png" alt="CI3"></p>
<p>复制生成的 token 并在 Travis CI 页面中配置Environment Variables。环境变量名称 <code>GH_TOKEN</code>，一定设置Log为不可见（private，有一把小锁显示），否则有安全隐患。</p>
<h2 id="配置-travis-yml"><a href="#配置-travis-yml" class="headerlink" title="配置 .travis.yml"></a>配置 <code>.travis.yml</code></h2><p><code>.travis.yml</code> 放在仓库根目录下。</p>
<p>特别注意的是，由于主题配置文件<code>_config.yml</code>会有敏感信息，所以将其作为私有的子模块处理，clone 需要使用 Github token。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span>   <span class="comment"># 设置语言</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span>     <span class="comment"># 设置相应的版本</span></span><br><span class="line"></span><br><span class="line"><span class="attr">git:</span></span><br><span class="line">  <span class="attr">submodules:</span></span><br><span class="line">    <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cache:</span></span><br><span class="line"><span class="comment">#     directories:</span></span><br><span class="line"><span class="comment">#         - node_modules    # 据说可以减少Travis构建时间</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">export</span> <span class="string">TZ='Asia/Shanghai'</span>   <span class="comment"># 更改时区</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">node</span> <span class="string">--version</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">--version</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span> <span class="comment"># 安装hexo插件</span></span><br><span class="line">  <span class="comment"># - npm install gulp -g     # 安装静态页面压缩插件</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span>   <span class="comment"># 安装hexo插件</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">--quiet</span> <span class="string">"https://$&#123;GH_TOKEN&#125;@$&#123;GH_THEME&#125;"</span> <span class="string">themes/next</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span>   <span class="comment"># 清除</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span>   <span class="comment"># 生成</span></span><br><span class="line">  <span class="comment"># - gulp</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">https://$&#123;GH_REF&#125;</span> <span class="string">.deploy_git</span>  <span class="comment"># GH_REF是最下面配置的仓库地址</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">.deploy_git</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">checkout</span> <span class="string">master</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">../</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mv</span> <span class="string">.deploy_git/.git/</span> <span class="string">./public/</span>   <span class="comment"># 这一步之前的操作是为了保留master分支的提交记录，不然每次git init的话只有1条commit</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"liziwl"</span>  <span class="comment"># 修改name</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"leezisy@gmail.com"</span>  <span class="comment"># 修改email</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">"Travis-CI Auto Builder at `date +"</span><span class="string">%Y-%m-%d</span> <span class="string">%H:%M"`"</span>  <span class="comment"># 提交记录包含时间 跟上面更改时区配合</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="string">--quiet</span> <span class="string">"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;"</span> <span class="string">master:master</span>  <span class="comment"># GH_TOKEN是在Travis中配置环境变量的名称</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">src</span>  <span class="comment"># 只监测这个分支，一有动静就开始构建</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">    <span class="attr">global:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">GH_REF:</span> <span class="string">github.com/liziwl/liziwl.github.io.git</span>    <span class="comment"># hexo 仓库地址</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">GH_THEME:</span> <span class="string">github.com/liziwl/hexo-theme-next-mod.git</span>   <span class="comment"># hexo 主题地址</span></span><br></pre></td></tr></table></figure>

<h2 id="Push-到-GitHub"><a href="#Push-到-GitHub" class="headerlink" title="Push 到 GitHub"></a>Push 到 GitHub</h2><p>在<code>_posts</code>目录下新建文章并 <code>push</code> 分支，登陆 <code>Travis CI</code> 即可发现已经检测到分支变化并开始构建，其中<code>Job log</code>记录了构建的过程。</p>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>目前不清楚原因，Travis 中使用 <code>gulp</code> 压缩结果和本地不一样，导致 font-awesome 路径出错，干脆停用了，压缩效果其实一般般，如果不压缩图片的话，只能降低最多5%的空间。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>zerotier 配置 moon</title>
    <url>/2019/08/11/zerotier/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>由于国内网络的复杂的情况， ZeroTier 的点与点连接很有可能建立失败。此时机器之间的连接就会绕道国外，造成较大的延迟和丢包率。在 ZeroTier 1.2.0 版本之后，一项新的功能被加入进来：“自定义根服务器”，又称 moon。通过自定义的服务器作为跳板加速内网机器之间的互相访问。本文简要介绍了 ZeroTier moon 的设置方法。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li>公网机器A – moon</li>
<li>内网机器B</li>
</ol>
<a id="more"></a>

<h2 id="详细配置"><a href="#详细配置" class="headerlink" title="详细配置"></a>详细配置</h2><h3 id="生成及修改-moon-json"><a href="#生成及修改-moon-json" class="headerlink" title="生成及修改 moon.json"></a>生成及修改 moon.json</h3><p>首先ssh到机器 A 上，前往路径 <code>/var/lib/zerotier-one</code>，输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sh -c <span class="string">"zerotier-idtool initmoon identity.public &gt;&gt; moon.json"</span></span><br></pre></td></tr></table></figure>

<p>此命令会在当前目录下生成一个文件 <code>moon.json</code>，文件内容类似如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"id"</span>: <span class="string">"deadbeef00"</span>,</span><br><span class="line">  <span class="attr">"objtype"</span>: <span class="string">"world"</span>,</span><br><span class="line">  <span class="attr">"roots"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"identity"</span>: <span class="string">"deadbeef00:0:34031483094..."</span>,</span><br><span class="line">      <span class="attr">"stableEndpoints"</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"signingKey"</span>: <span class="string">"b324d84cec708d1b51d5ac03e75afba501a12e2124705ec34a614bf8f9b2c800f44d9824ad3ab2e3da1ac52ecb39ac052ce3f54e58d8944b52632eb6d671d0e0"</span>,</span><br><span class="line">  <span class="attr">"signingKey_SECRET"</span>: <span class="string">"ffc5dd0b2baf1c9b220d1c9cb39633f9e2151cf350a6d0e67c913f8952bafaf3671d2226388e1406e7670dc645851bf7d3643da701fd4599fedb9914c3918db3"</span>,</span><br><span class="line">  <span class="attr">"updatesMustBeSignedBy"</span>: <span class="string">"b324d84cec708d1b51d5ac03e75afba501a12e2124705ec34a614bf8f9b2c800f44d9824ad3ab2e3da1ac52ecb39ac052ce3f54e58d8944b52632eb6d671d0e0"</span>,</span><br><span class="line">  <span class="attr">"worldType"</span>: <span class="string">"moon"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>&quot;identity&quot;</code> 为机器 A 在 <code>/var/lib/zerotier-one/identity.public</code>，应该已经导入无需修改</p>
<p>修改 <code>&quot;stableEndpoints&quot;</code> 为机器 A 的公网的 IP。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;stableEndpoints&quot;: [ &quot;1.2.3.4&#x2F;9993&quot;,&quot;2001:abcd:abcd::1&#x2F;9993&quot; ]</span><br></pre></td></tr></table></figure>

<p>若公网机器没有 IPv6 地址，则将其修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;stableEndpoints&quot;: [ &quot;1.2.3.4&#x2F;9993&quot; ]</span><br></pre></td></tr></table></figure>

<h3 id="生成签名文件"><a href="#生成签名文件" class="headerlink" title="生成签名文件"></a>生成签名文件</h3><p>修改完 <code>moon.json</code> 后，执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo zerotier-idtool genmoon moon.json</span><br></pre></td></tr></table></figure>

<p>此命令会生成一个签名文件在当前目录下，文件名如 <code>000000deadbeef00.moon</code> （机器 A 的 id 为 <code>deadbeef00</code>)</p>
<h3 id="将-moon-节点加入-ZeroTier-网络"><a href="#将-moon-节点加入-ZeroTier-网络" class="headerlink" title="将 moon 节点加入 ZeroTier 网络"></a>将 moon 节点加入 ZeroTier 网络</h3><p>在机器 A 中的 ZeroTier 目录中建立子文件夹 <code>moons.d</code></p>
<p>Linux: <code>/var/lib/zerotier-one</code><br>将在机器 A 生成的 <code>000000deadbeef00.moon</code> 拷贝进 <code>moons.d</code> 文件夹中，并重启 ZeroTier（此步好像有些许 bug，重启电脑为佳）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo killall -9 zerotier-one <span class="comment"># 关闭</span></span><br><span class="line">sudo zerotier-one -d <span class="comment"># 启动</span></span><br></pre></td></tr></table></figure>

<h3 id="其他节点连接-moon-节点"><a href="#其他节点连接-moon-节点" class="headerlink" title="其他节点连接 moon 节点"></a>其他节点连接 moon 节点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo zerotier-cli orbit deadbeef00 deadbeef00</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zerotier.com/manual.shtml#4_4" target="_blank" rel="noopener">ZeroTier | Manual – 4.4. Creating Your Own Roots (a.k.a. Moons)</a></p>
]]></content>
      <categories>
        <category>计算机拾遗</category>
      </categories>
  </entry>
  <entry>
    <title>C语言笔记-makefile</title>
    <url>/2017/09/18/C-notes2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。</p>
<a id="more"></a>

<p>因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。</p>
<p>makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。</p>
<p>现在讲述如何写makefile的文章比较少，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在”文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat Linux 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。</p>
<p>在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。</p>
<h2 id="关于程序的编译和链接"><a href="#关于程序的编译和链接" class="headerlink" title="关于程序的编译和链接"></a>关于程序的编译和链接</h2><p>在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。</p>
<p>编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。</p>
<p>链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫”库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。</p>
<p>总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的Object File.</p>
<p>好，言归正传，GNU的make有许多的内容，闲言少叙，还是让我们开始吧。</p>
<h2 id="Makefile-介绍"><a href="#Makefile-介绍" class="headerlink" title="Makefile 介绍"></a>Makefile 介绍</h2><p>make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。</p>
<p>首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：</p>
<ul>
<li>如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。</li>
<li>如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。</li>
<li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</li>
</ul>
<p>只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。</p>
<h3 id="Makefile的规则"><a href="#Makefile的规则" class="headerlink" title="Makefile的规则"></a>Makefile的规则</h3><p>在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">target ...: prerequisites ...</span><br><span class="line">    command</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的”伪目标”章节中会有叙述。prerequisites就是，要生成那个target所需要的文件或是目标。command也就是make需要执行的命令。（任意的Shell命令）</p>
<p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。</p>
<p>说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）</p>
<h3 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h3><p>正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">edit: main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o: main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o: kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o: command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o: display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o: insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o: search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o: files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o: utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>反斜杠（/）是换行符的意思。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为”Makefile”或”makefile”的文件中，然后在该目录下直接输入命令”make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下”make clean”就可以了。</p>
<p>在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p>
<p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p>
<p>这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p>
<h3 id="make是如何工作的"><a href="#make是如何工作的" class="headerlink" title="make是如何工作的"></a>make是如何工作的</h3><p>在默认的方式下，也就是我们只输入make命令。那么，</p>
<ul>
<li>make会在当前目录下找名字叫”Makefile”或”makefile”的文件。</li>
<li>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到”edit”这个文件，并把这个文件作为最终的目标文件。</li>
<li>如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。</li>
<li>如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）</li>
<li>当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生命make的终极任务，也就是执行文件edit了。</li>
</ul>
<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p>
<p>通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译。</p>
<p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。</p>
<p>而如果我们改变了”command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。</p>
<h3 id="makefile中使用变量"><a href="#makefile中使用变量" class="headerlink" title="makefile中使用变量"></a>makefile中使用变量</h3><p>在上面的例子中，先让我们看看edit的规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">edit: main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏可能会更好。</p>
<p>比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：<br><code>objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</code></p>
<p>于是，我们就可以很方便地在我们的makefile中以”$(objects)”的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects &#x3D; main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line">edit: $(objects)</span><br><span class="line">    cc -o edit $(objects)</span><br><span class="line">main.o: main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o: kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o: command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o: display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o: insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o: search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o: files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o: utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit $(objects)</span><br></pre></td></tr></table></figure>
<p>于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。<br>关于变量更多的话题，我会在后续给你一一道来。</p>
<h3 id="让make自动推导"><a href="#让make自动推导" class="headerlink" title="让make自动推导"></a>让make自动推导</h3><p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p>
<p>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects &#x3D; main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line">edit: $(objects)</span><br><span class="line">    cc -o edit $(objects)</span><br><span class="line">main.o: defs.h</span><br><span class="line">kbd.o: defs.h command.h</span><br><span class="line">command.o: defs.h command.h</span><br><span class="line">display.o: defs.h buffer.h</span><br><span class="line">insert.o: defs.h buffer.h</span><br><span class="line">search.o: defs.h buffer.h</span><br><span class="line">files.o: defs.h buffer.h command.h</span><br><span class="line">utils.o: defs.h</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean :</span><br><span class="line">    rm edit $(objects)</span><br></pre></td></tr></table></figure>
<p>这种方法，也就是make的”隐晦规则”。上面文件内容中，”.PHONY”表示，clean是个伪目标文件。</p>
<p>关于更为详细的”隐晦规则”和”伪目标文件”，我会在后续给你一一道来。</p>
<h3 id="另类风格的makefile"><a href="#另类风格的makefile" class="headerlink" title="另类风格的makefile"></a>另类风格的makefile</h3><p>即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects &#x3D; main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit: $(objects)</span><br><span class="line">    cc -o edit $(objects)</span><br><span class="line"></span><br><span class="line">$(objects): defs.h</span><br><span class="line">kbd.o command.o files.o: command.h</span><br><span class="line">display.o insert.o search.o files.o: buffer.h</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line">clean :</span><br><span class="line">    rm edit $(objects)</span><br></pre></td></tr></table></figure>
<p>这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。</p>
<h3 id="清空目标文件的规则"><a href="#清空目标文件的规则" class="headerlink" title="清空目标文件的规则"></a>清空目标文件的规则</h3><p>每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个”修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">    rm edit $(objects)</span><br></pre></td></tr></table></figure>
<p>更为稳健的做法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">clean :</span><br><span class="line">    -rm edit $(objects)</span><br></pre></td></tr></table></figure>
<p>前面说过，.PHONY意思表示clean是一个”伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。</p>
<p>上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。</p>
<h2 id="Makefile-总述"><a href="#Makefile-总述" class="headerlink" title="Makefile 总述"></a>Makefile 总述</h2><h3 id="Makefile里有什么？"><a href="#Makefile里有什么？" class="headerlink" title="Makefile里有什么？"></a>Makefile里有什么？</h3><p>Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。</p>
<ul>
<li>显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。</li>
<li>隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。</li>
<li>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</li>
<li>文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</li>
<li>注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用”#”字符，这个就像C/C++中的”//“一样。如果你要在你的Makefile中使用”#”字符，可以用反斜框进行转义，如：”/#”。</li>
</ul>
<p>最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。</p>
<h3 id="Makefile的文件名"><a href="#Makefile的文件名" class="headerlink" title="Makefile的文件名"></a>Makefile的文件名</h3><p>默认的情况下，make命令会在当前目录下按顺序找寻文件名为”GNUmakefile”、”makefile”、”Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用”Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用”GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的”makefile”文件名敏感，但是基本上来说，大多数的make都支持”makefile”和”Makefile”这两种默认文件名。</p>
<p>当然，你可以使用别的文件名来书写Makefile，比如：”Make.Linux”，”Make.Solaris”，”Make.AIX”等，如果要指定特定的Makefile，你可以使用make的”-f”和”–file”参数，如：make -f Make.Linux或make –file Make.AIX。</p>
<h3 id="引用其它的Makefile"><a href="#引用其它的Makefile" class="headerlink" title="引用其它的Makefile"></a>引用其它的Makefile</h3><p>在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：<br><code>include [filename]</code><br>filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）</p>
<p>在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和[filename]可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：<br><code>include foo.make *.mk $(bar)</code><br>等价于：<br><code>include foo.make a.mk b.mk c.mk e.mk f.mk</code></p>
<p>make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p>
<ul>
<li>如果make执行时，有”-I”或”–include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。</li>
<li>如果目录[prefix]/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。</li>
</ul>
<p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号”-“。如：<br><code>-include [filename]</code><br>其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。</p>
<h3 id="环境变量-MAKEFILES"><a href="#环境变量-MAKEFILES" class="headerlink" title="环境变量 MAKEFILES"></a>环境变量 MAKEFILES</h3><p>如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的”目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p>
<p>但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。</p>
<h3 id="make的工作方式"><a href="#make的工作方式" class="headerlink" title="make的工作方式"></a>make的工作方式</h3><p>GNU的make工作时的执行步骤入下：（想来其它的make也是类似）</p>
<ul>
<li>读入所有的Makefile。</li>
<li>读入被include的其它Makefile。</li>
<li>初始化文件中的变量。</li>
<li>推导隐晦规则，并分析所有规则。</li>
<li>为所有的目标文件创建依赖关系链。</li>
<li>根据依赖关系，决定哪些目标要重新生成。</li>
<li>执行生成命令。</li>
</ul>
<p>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。</p>
<p>当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。</p>
<h2 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h2><p>规则包含两个部分，一个是依赖关系，一个是生成目标的方法。</p>
<p>在Makefile中，规则的顺序是很重要的，因为，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。</p>
<p>好了，还是让我们来看一看如何书写规则。</p>
<h3 id="规则举例"><a href="#规则举例" class="headerlink" title="规则举例"></a>规则举例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo.o: foo.c defs.h       # foo模块</span><br><span class="line">    cc -c -g foo.c</span><br></pre></td></tr></table></figure>
<p>看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令”cc -c -g foo.c”（以Tab键开头）。这个规则告诉我们两件事：</p>
<ul>
<li>文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。</li>
<li>如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件）</li>
</ul>
<h3 id="规则的语法"><a href="#规则的语法" class="headerlink" title="规则的语法"></a>规则的语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">targets: prerequisites</span><br><span class="line">    command</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>或是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">targets: prerequisites ; command</span><br><span class="line">    command</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。</p>
<p>command是命令行，如果其不与”target:prerequisites”在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）</p>
<p>prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是”过时的”，被认为是需要重生成的。这个在前面已经讲过了。</p>
<p>如果命令太长，你可以使用反斜框（‘/’）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何成成目标文件。</p>
<p>一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。</p>
<h3 id="在规则中使用通配符"><a href="#在规则中使用通配符" class="headerlink" title="在规则中使用通配符"></a>在规则中使用通配符</h3><p>如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三各通配符：”*”，”?”和”[…]”。这是和Unix的B-Shell是相同的。</p>
<p>波浪号（”<del>“）字符在文件名中也有比较特殊的用途。如果是”</del>/test”，这就表示当前用户的$HOME目录下的test目录。而”~hchen/test”则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量”HOME”而定。</p>
<p>通配符代替了你一系列的文件，如”<em>.c”表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：”</em>“，那么可以用转义字符”/“，如”/<em>“来表示真实的”</em>“字符，而不是任意长度的字符串。</p>
<p>好吧，还是先来看几个例子吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">    rm -f *.o</span><br></pre></td></tr></table></figure>
<p>上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print: *.c</span><br><span class="line">    lpr -p $?</span><br><span class="line">    touch print</span><br></pre></td></tr></table></figure>
<p>上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的[.c]文件。其中的”$?”是一个自动化变量，我会在后面给你讲述。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects &#x3D; *.o</span><br></pre></td></tr></table></figure>
<p>上面这个例子，表示了，通符同样可以用在变量中。并不是说[<em>.o]会展开，不！objects的值就是”</em>.o”。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects :&#x3D; $(wildcard *.o)</span><br></pre></td></tr></table></figure>
<p>这种用法由关键字”wildcard”指出，关于Makefile的关键字，我们将在后面讨论。</p>
<h3 id="文件搜寻"><a href="#文件搜寻" class="headerlink" title="文件搜寻"></a>文件搜寻</h3><p>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。</p>
<p>Makefile文件中的特殊变量”VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VPATH &#x3D; src:..&#x2F;headers</span><br></pre></td></tr></table></figure>
<p>上面的的定义指定两个目录，”src”和”../headers”，make会按照这个顺序进行搜索。目录由”冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）</p>
<p>另一个设置文件搜索路径的方法是使用make的”vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：</p>
<ul>
<li>vpath [pattern] [directories]<br>为符合模式[pattern]的文件指定搜索目录[directories]。</li>
<li>vpath [pattern]<br>清除符合模式[pattern]的文件的搜索目录。</li>
<li>vpath<br>清除所有已被设置好了的文件搜索目录。</li>
</ul>
<p>vapth使用方法中的[pattern]需要包含”%”字符。”%”的意思是匹配零或若干字符，例如，”%.h”表示所有以”.h”结尾的文件。[pattern]指定了要搜索的文件集，而[directories]则指定了[pattern]的文件集的搜索的目录。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vpath %.h ..&#x2F;headers</span><br></pre></td></tr></table></figure>
<p>该语句表示，要求make在”../headers”目录下搜索所有以”.h”结尾的文件。（如果某文件在当前目录没有找到的话）</p>
<p>我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的[pattern]，或是被重复了的[pattern]，那么，make会按照vpath语句的先后顺序来执行搜索。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vpath %.c foo</span><br><span class="line">vpath %   blish</span><br><span class="line">vpath %.c bar</span><br></pre></td></tr></table></figure>
<p>其表示”.c”结尾的文件，先在”foo”目录，然后是”blish”，最后是”bar”目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vpath %.c foo:bar</span><br><span class="line">vpath %   blish</span><br></pre></td></tr></table></figure>
<p>而上面的语句则表示”.c”结尾的文件，先在”foo”目录，然后是”bar”目录，最后才是”blish”目录。</p>
<h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>最早先的一个例子中，我们提到过一个”clean”的目标，这是一个”伪目标”，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">    rm *.o temp</span><br></pre></td></tr></table></figure>
<p>正像我们前面例子中的”clean”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的”目标”以备完整地重编译而用。 （以”make clean”来使用该目标）</p>
<p>因为，我们并不生成”clean”这个文件。”伪目标”并不是一个文件，只是一个标签，由于”伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个”目标”才能让其生效。当然，”伪目标”的取名不能和文件名重名，不然其就失去了”伪目标”的意义了。</p>
<p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记”.PHONY”来显示地指明一个目标是”伪目标”，向make说明，不管是否有这个文件，这个目标就是”伪目标”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure>
<p>只要有这个声明，不管是否有”clean”文件，要运行”clean”这个目标，只有”make clean”这样。于是整个过程可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">    rm *.o temp</span><br></pre></td></tr></table></figure>
<p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为”默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用”伪目标”这个特性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">all: prog1 prog2 prog3</span><br><span class="line">.PHONY: all</span><br><span class="line"></span><br><span class="line">prog1: prog1.o utils.o</span><br><span class="line">    cc -o prog1 prog1.o utils.o</span><br><span class="line"></span><br><span class="line">prog2: prog2.o</span><br><span class="line">    cc -o prog2 prog2.o</span><br><span class="line"></span><br><span class="line">prog3: prog3.o sort.o utils.o</span><br><span class="line">    cc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure>
<p>我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个”all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如”all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。”.PHONY: all”声明了”all”这个目标为”伪目标”。</p>
<p>随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY: cleanall cleanobj cleandiff</span><br><span class="line"></span><br><span class="line">cleanall: cleanobj cleandiff</span><br><span class="line">    rm program</span><br><span class="line"></span><br><span class="line">cleanobj :</span><br><span class="line">    rm *.o</span><br><span class="line"></span><br><span class="line">cleandiff :</span><br><span class="line">    rm *.diff</span><br></pre></td></tr></table></figure>
<p>“make clean”将清除所有要被清除的文件。”cleanobj”和”cleandiff”这两个伪目标有点像”子程序”的意思。我们可以输入”make cleanall”和”make cleanobj”和”make cleandiff”命令来达到清除不同种类文件的目的。</p>
<h3 id="多目标"><a href="#多目标" class="headerlink" title="多目标"></a>多目标</h3><p>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量”$@”（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bigoutput littleoutput: text.g</span><br><span class="line">    generate text.g -$(subst output,,$@) ] $@</span><br></pre></td></tr></table></figure>
<p>上述规则等价于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bigoutput: text.g</span><br><span class="line">    generate text.g -big ] bigoutput</span><br><span class="line">littleoutput: text.g</span><br><span class="line">    generate text.g -little ] littleoutput</span><br></pre></td></tr></table></figure>
<p>其中，-$(subst output,,$@)中的”$”表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，”$@”表示目标的集合，就像一个数组，”$@”依次取出目标，并执于命令。</p>
<h3 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h3><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[targets ...]: [target-pattern]: [prereq-patterns ...]</span><br><span class="line">    [commands]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。<br>target-parrtern是指明了targets的模式，也就是的目标集模式。<br>prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。</p>
<p>这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的[target-parrtern]定义成”%.o”，意思是我们的[target]集合中都是以”.o”结尾的，而如果我们的[prereq-parrterns]定义成”%.c”，意思是对[target-parrtern]所形成的目标集进行二次定义，其计算方法是，取[target-parrtern]模式中的”%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。</p>
<p>所以，我们的”目标模式”或是”依赖模式”中都应该有”%”这个字符，如果你的文件名中有”%”那么你可以使用反斜杠”/“进行转义，来标明真实的”%”字符。</p>
<p>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects &#x3D; foo.o bar.o</span><br><span class="line"></span><br><span class="line">all: $(objects)</span><br><span class="line"></span><br><span class="line">$(objects): %.o: %.c</span><br><span class="line">    $(CC) -c $(CFLAGS) $[ -o $@</span><br></pre></td></tr></table></figure>
<p>上面的例子中，指明了我们的目标从$object中获取，”%.o”表明要所有以”.o”结尾的目标，也就是”foo.o bar.o”，也就是变量$object集合的模式，而依赖模式”%.c”则取模式”%.o”的”%”，也就是”foo bar”，并为其加下”.c”的后缀，于是，我们的依赖目标就是”foo.c bar.c”。而命令中的”$[“和”$@”则是自动化变量，”$[“表示所有的依赖目标集（也就是”foo.c bar.c”），”$@”表示目标集（也就是”foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo.o: foo.c</span><br><span class="line">    $(CC) -c $(CFLAGS) foo.c -o foo.o</span><br><span class="line">bar.o: bar.c</span><br><span class="line">    $(CC) -c $(CFLAGS) bar.c -o bar.o</span><br></pre></td></tr></table></figure>
<p>试想，如果我们的”%.o”有几百个，那种我们只要用这种很简单的”静态模式规则”就可以写完一堆规则，实在是太有效率了。”静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">files &#x3D; foo.elc bar.o lose.o</span><br><span class="line"></span><br><span class="line">$(filter %.o,$(files)): %.o: %.c</span><br><span class="line">    $(CC) -c $(CFLAGS) $[ -o $@</span><br><span class="line">$(filter %.elc,$(files)): %.elc: %.el</span><br><span class="line">    emacs -f batch-byte-compile $[</span><br></pre></td></tr></table></figure>
<p>$(filter %.o,$(files))表示调用Makefile的filter函数，过滤”$filter”集，只要其中模式为”%.o”的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。</p>
<h3 id="自动生成依赖性"><a href="#自动生成依赖性" class="headerlink" title="自动生成依赖性"></a>自动生成依赖性</h3><p>在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句”#include “defs.h””，那么我们的依赖关系应该是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main.o: main.c defs.h</span><br></pre></td></tr></table></figure>
<p>但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个”-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc -M main.c</span><br></pre></td></tr></table></figure>
<p>其输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main.o: main.c defs.h</span><br></pre></td></tr></table></figure>
<p>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用”-MM”参数，不然，”-M”参数会把一些标准库的头文件也包含进来。</p>
<p>gcc -M main.c的输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main.o: main.c defs.h &#x2F;usr&#x2F;include&#x2F;stdio.h &#x2F;usr&#x2F;include&#x2F;features.h &#x2F;</span><br><span class="line">     &#x2F;usr&#x2F;include&#x2F;sys&#x2F;cdefs.h &#x2F;usr&#x2F;include&#x2F;gnu&#x2F;stubs.h &#x2F;</span><br><span class="line">     &#x2F;usr&#x2F;lib&#x2F;gcc-lib&#x2F;i486-suse-linux&#x2F;2.95.3&#x2F;include&#x2F;stddef.h &#x2F;</span><br><span class="line">     &#x2F;usr&#x2F;include&#x2F;bits&#x2F;types.h &#x2F;usr&#x2F;include&#x2F;bits&#x2F;pthreadtypes.h &#x2F;</span><br><span class="line">     &#x2F;usr&#x2F;include&#x2F;bits&#x2F;sched.h &#x2F;usr&#x2F;include&#x2F;libio.h &#x2F;</span><br><span class="line">     &#x2F;usr&#x2F;include&#x2F;_G_config.h &#x2F;usr&#x2F;include&#x2F;wchar.h &#x2F;</span><br><span class="line">     &#x2F;usr&#x2F;include&#x2F;bits&#x2F;wchar.h &#x2F;usr&#x2F;include&#x2F;gconv.h &#x2F;</span><br><span class="line">     &#x2F;usr&#x2F;lib&#x2F;gcc-lib&#x2F;i486-suse-linux&#x2F;2.95.3&#x2F;include&#x2F;stdarg.h &#x2F;</span><br><span class="line">     &#x2F;usr&#x2F;include&#x2F;bits&#x2F;stdio_lim.h</span><br></pre></td></tr></table></figure>
<p>gcc -MM main.c的输出则是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main.o: main.c defs.h</span><br></pre></td></tr></table></figure>
<p>那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让Makefile自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个”name.c”的文件都生成一个”name.d”的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。</p>
<p>于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。</p>
<p>这里，我们给出了一个模式规则来产生[.d]文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%.d: %.c</span><br><span class="line">    @set -e; rm -f $@; &#x2F;</span><br><span class="line">        $(CC) -M $(CPPFLAGS) $[ ] $@.$$$$; &#x2F;</span><br><span class="line">        sed &#39;s,&#x2F;($*&#x2F;)&#x2F;.o[ :]*,&#x2F;1.o $@: ,g&#39; [ $@.$$$$ ] $@; &#x2F;</span><br><span class="line">        rm -f $@.$$$$</span><br></pre></td></tr></table></figure>
<p>这个规则的意思是，所有的[.d]文件依赖于[.c]文件，”rm -f $@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件”$[“，也就是[.c]文件生成依赖文件，”$@”表示模式”%.d”文件，如果有一个C文件是name.c，那么”%”就是”name”，”$$$$”意为一个随机编号，第二行生成的文件有可能是”name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。</p>
<p>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main.o: main.c defs.h</span><br></pre></td></tr></table></figure>
<p>转成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main.o main.d: main.c defs.h</span><br></pre></td></tr></table></figure>
<p>于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的”include”命令，来引入别的Makefile文件（前面讲过），例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sources &#x3D; foo.c bar.c</span><br><span class="line">include $(sources:.c&#x3D;.d)</span><br></pre></td></tr></table></figure>
<p>上述语句中的”$(sources:.c=.d)”中的”.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]，关于这个”替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标。</p>
<h2 id="书写命令"><a href="#书写命令" class="headerlink" title="书写命令"></a>书写命令</h2><p>每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。</p>
<p>我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被”/bin/sh”——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，”#”是注释符，很像C/C++中的”//“，其后的本行字符都被注释。</p>
<h3 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h3><p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用”@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@echo 正在编译XXX模块......</span><br></pre></td></tr></table></figure>
<p>当make执行时，会输出”正在编译XXX模块……”字串，但不会输出命令，如果没有”@”，那么，make将输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 正在编译XXX模块......</span><br><span class="line">正在编译XXX模块......</span><br></pre></td></tr></table></figure>
<p>如果make执行时，带入make参数”-n”或”–just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。</p>
<p>而make参数”-s”或”–slient”则是全面禁止命令的显示。</p>
<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：<br>示例一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec:</span><br><span class="line">    cd &#x2F;home&#x2F;hchen</span><br><span class="line">    pwd</span><br></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec:</span><br><span class="line">    cd &#x2F;home&#x2F;hchen; pwd</span><br></pre></td></tr></table></figure>
<p>当我们执行”make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出”/home/hchen”。</p>
<p>make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS-DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如”.exe”、”.com”、”.bat”、”.sh”等后缀。</p>
<h3 id="命令出错"><a href="#命令出错" class="headerlink" title="命令出错"></a>命令出错</h3><p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</p>
<p>有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。</p>
<p>为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号”-“（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">    -rm -f *.o</span><br></pre></td></tr></table></figure>
<p>还有一个全局的办法是，给make加上”-i”或是”–ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以”.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。</p>
<p>还有一个要提一下的make的参数的是”-k”或是”–keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。</p>
<h3 id="嵌套执行make"><a href="#嵌套执行make" class="headerlink" title="嵌套执行make"></a>嵌套执行make</h3><p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。</p>
<p>例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subsystem:</span><br><span class="line">    cd subdir &amp;&amp; $(MAKE)</span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subsystem:</span><br><span class="line">    $(MAKE) -C subdir</span><br></pre></td></tr></table></figure>
<p>定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入”subdir”目录，然后执行make命令。</p>
<p>我们把这个Makefile叫做”总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了”-e”参数。</p>
<p>如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export [variable ...]</span><br></pre></td></tr></table></figure>
<p>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unexport [variable ...]</span><br></pre></td></tr></table></figure>
<p>如：<br>示例一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export variable &#x3D; value</span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">variable &#x3D; value</span><br><span class="line">export variable</span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export variable :&#x3D; value</span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">variable :&#x3D; value</span><br><span class="line">export variable</span><br></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export variable +&#x3D; value</span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">variable +&#x3D; value</span><br><span class="line">export variable</span><br></pre></td></tr></table></figure>
<p>如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。</p>
<p>需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行”总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。</p>
<p>但是make命令中的有几个参数并不往下传递，它们是”-C”,”-f”,”-h””-o”和”-W”（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subsystem:</span><br><span class="line">    cd subdir &amp;&amp; $(MAKE) MAKEFLAGS&#x3D;</span><br></pre></td></tr></table></figure>
<p>如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有”-t”,”-n”,和”-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。</p>
<p>还有一个在”嵌套执行”中比较有用的参数，”-w”或是”–print-directory”会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是”/home/hchen/gnu/make”，如果我们使用”make -w”来执行，那么当进入该目录时，我们会看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make: Entering directory &#96;&#x2F;home&#x2F;hchen&#x2F;gnu&#x2F;make&#39;.</span><br></pre></td></tr></table></figure>
<p>而在完成下层make后离开目录时，我们会看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make: Leaving directory &#96;&#x2F;home&#x2F;hchen&#x2F;gnu&#x2F;make&#39;</span><br></pre></td></tr></table></figure>
<p>当你使用”-C”参数来指定make下层Makefile时，”-w”会被自动打开的。如果参数中有”-s”（”–slient”）或是”–no-print-directory”，那么，”-w”总是失效的。</p>
<h3 id="定义命令包"><a href="#定义命令包" class="headerlink" title="定义命令包"></a>定义命令包</h3><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以”define”开始，以”endef”结束，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define run-yacc</span><br><span class="line">yacc $(firstword $^)</span><br><span class="line">mv y.tab.c $@</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>这里，”run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在”define”和”endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成”y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo.c: foo.y</span><br><span class="line">    $(run-yacc)</span><br></pre></td></tr></table></figure>
<p>我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包”run-yacc”中的”$^”就是”foo.y”，”$@”就是”foo.c”（有关这种以”$”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。</p>
<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>在Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在”目标”，”依赖目标”，”命令”或是Makefile的其它部分中。</p>
<p>变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有”:”、”#”、”=”或是空字符（空格、回车等）。变量是大小写敏感的，”foo”、”Foo”和”FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。</p>
<p>有一些变量是很奇怪字串，如”$[“、”$@”等，这些是自动化变量，我会在后面介绍。</p>
<h3 id="变量的基础"><a href="#变量的基础" class="headerlink" title="变量的基础"></a>变量的基础</h3><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上”$”符号，但最好用小括号”（）”或是大括号”{}”把变量给包括起来。如果你要使用真实的”$”字符，那么你需要用”$$”来表示。</p>
<p>变量可以使用在许多地方，如规则中的”目标”、”依赖”、”命令”以及新的变量中。先看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects &#x3D; program.o foo.o utils.o</span><br><span class="line">program: $(objects)</span><br><span class="line">    cc -o program $(objects)</span><br><span class="line"></span><br><span class="line">$(objects): defs.h</span><br></pre></td></tr></table></figure>
<p>变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo &#x3D; c</span><br><span class="line">prog.o: prog.$(foo)</span><br><span class="line">    $(foo)$(foo) -$(foo) prog.$(foo)</span><br></pre></td></tr></table></figure>
<p>展开后得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prog.o: prog.c</span><br><span class="line">    cc -c prog.c</span><br></pre></td></tr></table></figure>
<p>当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个”替代”的原理。</p>
<p>另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。</p>
<h3 id="变量中的变量"><a href="#变量中的变量" class="headerlink" title="变量中的变量"></a>变量中的变量</h3><p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。</p>
<p>先看第一种方式，也就是简单的使用”=”号，在”=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo &#x3D; $(bar)</span><br><span class="line">bar &#x3D; $(ugh)</span><br><span class="line">ugh &#x3D; Huh?</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">    echo $(foo)</span><br></pre></td></tr></table></figure>
<p>我们执行”make all”将会打出变量$(foo)的值是”Huh?”（ $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是”Huh?”）可见，变量是可以使用后面的变量来定义的。</p>
<p>这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFLAGS &#x3D; $(include_dirs) -O</span><br><span class="line">include_dirs &#x3D; -Ifoo -Ibar</span><br></pre></td></tr></table></figure>
<p>当”CFLAGS”在命令中被展开时，会是”-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFLAGS &#x3D; $(CFLAGS) -O</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A &#x3D; $(B)</span><br><span class="line">B &#x3D; $(A)</span><br></pre></td></tr></table></figure>
<p>这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数”wildcard”和”shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。</p>
<p>为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是”:=”操作符，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x :&#x3D; foo</span><br><span class="line">y :&#x3D; $(x) bar</span><br><span class="line">x :&#x3D; later</span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y :&#x3D; foo bar</span><br><span class="line">x :&#x3D; later</span><br></pre></td></tr></table></figure>
<p>值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y :&#x3D; $(x) bar</span><br><span class="line">x :&#x3D; foo</span><br></pre></td></tr></table></figure>
<p>那么，y的值是”bar”，而不是”foo bar”。</p>
<p>上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量”MAKELEVEL”的使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifeq (0,$&#123;MAKELEVEL&#125;)</span><br><span class="line">cur-dir   :&#x3D; $(shell pwd)</span><br><span class="line">whoami    :&#x3D; $(shell whoami)</span><br><span class="line">host-type :&#x3D; $(shell arch)</span><br><span class="line">MAKE :&#x3D; $&#123;MAKE&#125; host-type&#x3D;$&#123;host-type&#125; whoami&#x3D;$&#123;whoami&#125;</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>关于条件表达式和函数，我们在后面再说，对于系统变量”MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的”嵌套使用make”），那么，这个变量会记录了我们的当前Makefile的调用层数。</p>
<p>下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nullstring :&#x3D;</span><br><span class="line">space :&#x3D; $(nullstring) # end of the line</span><br></pre></td></tr></table></figure>
<p>nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采用”#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于”#”的使用，注释符”#”的这种特性值得我们注意，如果我们这样定义一个变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir :&#x3D; &#x2F;foo&#x2F;bar    # directory to put the frobs in</span><br></pre></td></tr></table></figure>
<p>dir这个变量的值是”/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。</p>
<p>还有一个比较有用的操作符是”?=”，先看示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FOO ?&#x3D; bar</span><br></pre></td></tr></table></figure>
<p>其含义是，如果FOO没有被定义过，那么变量FOO的值就是”bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifeq ($(origin FOO), undefined)</span><br><span class="line">    FOO &#x3D; bar</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<h3 id="变量高级用法"><a href="#变量高级用法" class="headerlink" title="变量高级用法"></a>变量高级用法</h3><p>这里介绍两种变量的高级使用方法，第一种是变量值的替换。</p>
<p>我们可以替换变量中的共有的部分，其格式是”$(var:a=b)”或是”${var:a=b}”，其意思是，把变量”var”中所有以”a”字串”结尾”的”a”替换成”b”字串。这里的”结尾”意思是”空格”或是”结束符”。</p>
<p>还是看一个示例吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo :&#x3D; a.o b.o c.o</span><br><span class="line">bar :&#x3D; $(foo:.o&#x3D;.c)</span><br></pre></td></tr></table></figure>
<p>这个示例中，我们先定义了一个”$(foo)”变量，而第二行的意思是把”$(foo)”中所有以”.o”字串”结尾”全部替换成”.c”，所以我们的”$(bar)”的值就是”a.c b.c c.c”。</p>
<p>另外一种变量替换的技术是以”静态模式”（参见前面章节）定义的，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo :&#x3D; a.o b.o c.o</span><br><span class="line">bar :&#x3D; $(foo:%.o&#x3D;%.c)</span><br></pre></td></tr></table></figure>
<p>这依赖于被替换字串中的有相同的模式，模式中必须包含一个”%”字符，这个例子同样让$(bar)变量的值为”a.c b.c c.c”。</p>
<p>第二种高级用法是——“把变量的值再当成变量”。先看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; y</span><br><span class="line">y &#x3D; z</span><br><span class="line">a :&#x3D; $($(x))</span><br></pre></td></tr></table></figure>
<p>在这个例子中，$(x)的值是”y”，所以$($(x))就是$(y)，于是$(a)的值就是”z”。（注意，是”x=y”，而不是”x=$(y)”）</p>
<p>我们还可以使用更多的层次：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; y</span><br><span class="line">y &#x3D; z</span><br><span class="line">z &#x3D; u</span><br><span class="line">a :&#x3D; $($($(x)))</span><br></pre></td></tr></table></figure>
<p>这里的$(a)的值是”u”，相关的推导留给读者自己去做吧。</p>
<p>让我们再复杂一点，使用上”在变量定义中使用变量”的第一个方式，来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; $(y)</span><br><span class="line">y &#x3D; z</span><br><span class="line">z &#x3D; Hello</span><br><span class="line">a :&#x3D; $($(x))</span><br></pre></td></tr></table></figure>
<p>这里的$($(x))被替换成了$($(y))，因为$(y)值是”z”，所以，最终结果是：a:=$(z)，也就是”Hello”。</p>
<p>再复杂一点，我们再加上函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; variable1</span><br><span class="line">variable2 :&#x3D; Hello</span><br><span class="line">y &#x3D; $(subst 1,2,$(x))</span><br><span class="line">z &#x3D; y</span><br><span class="line">a :&#x3D; $($($(z)))</span><br></pre></td></tr></table></figure>
<p>这个例子中，”$($($(z)))”扩展为”$($(y))”，而其再次被扩展为”$($(subst 1,2,$(x)))”。$(x)的值是”variable1”，subst函数把”variable1”中的所有”1”字串替换成”2”字串，于是，”variable1”变成”variable2”，再取其值，所以，最终，$(a)的值就是$(variable2)的值——“Hello”。（喔，好不容易）</p>
<p>在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">first_second &#x3D; Hello</span><br><span class="line">a &#x3D; first</span><br><span class="line">b &#x3D; second</span><br><span class="line">all &#x3D; $($a_$b)</span><br></pre></td></tr></table></figure>
<p>这里的”$a_$b”组成了”first_second”，于是，$(all)的值就是”Hello”。</p>
<p>再来看看结合第一种技术的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a_objects :&#x3D; a.o b.o c.o</span><br><span class="line">1_objects :&#x3D; 1.o 2.o 3.o</span><br><span class="line"></span><br><span class="line">sources :&#x3D; $($(a1)_objects:.o&#x3D;.c)</span><br></pre></td></tr></table></figure>
<p>这个例子中，如果$(a1)的值是”a”的话，那么，$(sources)的值就是”a.c b.c c.c”；如果$(a1)的值是”1”，那么$(sources)的值是”1.c 2.c 3.c”。</p>
<p>再来看一个这种技术和”函数”与”条件语句”一同使用的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifdef do_sort</span><br><span class="line">    func :&#x3D; sort</span><br><span class="line">else</span><br><span class="line">    func :&#x3D; strip</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">bar :&#x3D; a d b g q c</span><br><span class="line"></span><br><span class="line">foo :&#x3D; $($(func) $(bar))</span><br></pre></td></tr></table></figure>
<p>这个示例中，如果定义了”do_sort”，那么：<code>foo := $(sort a d b g q c)</code>，于是$(foo)的值就是”a b c d g q”，而如果没有定义”do_sort”，那么：<code>foo := $(sort a d b g q c)</code>，调用的就是strip函数。</p>
<p>当然，”把变量的值再当成变量”这种技术，同样可以用在操作符的左边：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir &#x3D; foo</span><br><span class="line">$(dir)_sources :&#x3D; $(wildcard $(dir)&#x2F;*.c)</span><br><span class="line">define $(dir)_print</span><br><span class="line">    lpr $($(dir)_sources)</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>这个例子中定义了三个变量：”dir”，”foo_sources”和”foo_print”。</p>
<h3 id="追加变量值"><a href="#追加变量值" class="headerlink" title="追加变量值"></a>追加变量值</h3><p>我们可以使用”+=”操作符给变量追加值，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects &#x3D; main.o foo.o bar.o utils.o</span><br><span class="line">objects +&#x3D; another.o</span><br></pre></td></tr></table></figure>
<p>于是，我们的$(objects)值变成：”main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）</p>
<p>使用”+=”操作符，可以模拟为下面的这种例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects &#x3D; main.o foo.o bar.o utils.o</span><br><span class="line">objects :&#x3D; $(objects) another.o</span><br></pre></td></tr></table></figure>
<p>所不同的是，用”+=”更为简洁。</p>
<p>如果变量之前没有定义过，那么，”+=”会自动变成”=”，如果前面有变量定义，那么”+=”会继承于前次操作的赋值符。如果前一次的是”:=”，那么”+=”会以”:=”作为其赋值符，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">variable :&#x3D; value</span><br><span class="line">variable +&#x3D; more</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">variable :&#x3D; value</span><br><span class="line">variable :&#x3D; $(variable) more</span><br></pre></td></tr></table></figure>
<p>但如果是这种情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">variable &#x3D; value</span><br><span class="line">variable +&#x3D; more</span><br></pre></td></tr></table></figure>
<p>由于前次的赋值符是”=”，所以”+=”也会以”=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。</p>
<h3 id="override-指示符"><a href="#override-指示符" class="headerlink" title="override 指示符"></a>override 指示符</h3><p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用”override”指示符。其语法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override [variable] &#x3D; [value]</span><br><span class="line">override [variable] :&#x3D; [value]</span><br></pre></td></tr></table></figure>
<p>当然，你还可以追加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override [variable] +&#x3D; [more text]</span><br></pre></td></tr></table></figure>
<p>对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用ovveride指示符，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override define foo</span><br><span class="line">    bar</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>

<h3 id="多行变量"><a href="#多行变量" class="headerlink" title="多行变量"></a>多行变量</h3><p>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过”命令包”的技术就是利用这个关键字）。</p>
<p>define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。其工作方式和”=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。</p>
<p>下面的这个示例展示了define的用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define two-lines</span><br><span class="line">    echo foo</span><br><span class="line">    echo $(bar)</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>

<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了”-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p>
<p>因此，如果我们在环境变量中设置了”CFLAGS”环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像”全局变量”和”局部变量”的特性。</p>
<p>当make嵌套调用时（参见前面的”嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）</p>
<p>当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。</p>
<h3 id="目标变量"><a href="#目标变量" class="headerlink" title="目标变量"></a>目标变量</h3><p>前面我们所讲的在Makefile中定义的变量都是”全局变量”，在整个文件，我们都可以访问这些变量。当然，”自动化变量”除外，如”$[“等这种类量的自动化变量就属于”规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。</p>
<p>当然，我样同样可以为某个目标设置局部变量，这种变量被称为”Target-specific Variable”，它可以和”全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p>
<p>其语法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[target ...]: [variable-assignment]</span><br><span class="line">[target ...]: overide [variable-assignment]</span><br><span class="line">[variable-assignment]</span><br></pre></td></tr></table></figure>
<p>可以是前面讲过的各种赋值表达式，如”=”、”:=”、”+=”或是”？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</p>
<p>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prog: CFLAGS &#x3D; -g</span><br><span class="line">prog: prog.o foo.o bar.o</span><br><span class="line">    $(CC) $(CFLAGS) prog.o foo.o bar.o</span><br><span class="line"></span><br><span class="line">prog.o: prog.c</span><br><span class="line">    $(CC) $(CFLAGS) prog.c</span><br><span class="line"></span><br><span class="line">foo.o: foo.c</span><br><span class="line">    $(CC) $(CFLAGS) foo.c</span><br><span class="line"></span><br><span class="line">bar.o: bar.c</span><br><span class="line">    $(CC) $(CFLAGS) bar.c</span><br></pre></td></tr></table></figure>
<p>在这个示例中，不管全局的$(CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），$(CFLAGS)的值都是”-g”</p>
<h3 id="模式变量"><a href="#模式变量" class="headerlink" title="模式变量"></a>模式变量</h3><p>在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种”模式”，可以把变量定义在符合这种模式的所有目标上。</p>
<p>我们知道，make的”模式”一般是至少含有一个”%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%.o: CFLAGS &#x3D; -O</span><br></pre></td></tr></table></figure>
<p>同样，模式变量的语法和”目标变量”一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[pattern ...]: [variable-assignment]</span><br><span class="line">[pattern ...]: override [variable-assignment]</span><br></pre></td></tr></table></figure>
<p>override同样是针对于系统环境传入的变量，或是make命令行指定的变量。</p>
<h2 id="使用条件判断"><a href="#使用条件判断" class="headerlink" title="使用条件判断"></a>使用条件判断</h2><p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面的例子，判断$(CC)变量是否”gcc”，如果是的话，则使用GNU函数编译目标。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libs_for_gcc &#x3D; -lgnu</span><br><span class="line">normal_libs &#x3D;</span><br><span class="line"></span><br><span class="line">foo: $(objects)</span><br><span class="line">ifeq ($(CC),gcc)</span><br><span class="line">    $(CC) -o foo $(objects) $(libs_for_gcc)</span><br><span class="line">else</span><br><span class="line">    $(CC) -o foo $(objects) $(normal_libs)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>可见，在上面示例的这个规则中，目标”foo”可以根据变量”$(CC)”值来选取不同的函数库来编译程序。</p>
<p>我们可以从上面的示例中看到三个关键字：ifeq、else和endif。ifeq的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。</p>
<p>当我们的变量$(CC)值是”gcc”时，目标foo的规则是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo: $(objects)</span><br><span class="line">    $(CC) -o foo $(objects) $(libs_for_gcc)</span><br></pre></td></tr></table></figure>
<p>而当我们的变量$(CC)值不是”gcc”时（比如”cc”），目标foo的规则是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo: $(objects)</span><br><span class="line">    $(CC) -o foo $(objects) $(normal_libs)</span><br></pre></td></tr></table></figure>
<p>当然，我们还可以把上面的那个例子写得更简洁一些：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libs_for_gcc &#x3D; -lgnu</span><br><span class="line">normal_libs &#x3D;</span><br><span class="line"></span><br><span class="line">ifeq ($(CC),gcc)</span><br><span class="line">    libs&#x3D;$(libs_for_gcc)</span><br><span class="line">else</span><br><span class="line">    libs&#x3D;$(normal_libs)</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">foo: $(objects)</span><br><span class="line">    $(CC) -o foo $(objects) $(libs)</span><br></pre></td></tr></table></figure>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>条件表达式的语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[conditional-directive]</span><br><span class="line">[text-if-true]</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>以及：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[conditional-directive]</span><br><span class="line">    [text-if-true]</span><br><span class="line">else</span><br><span class="line">    [text-if-false]</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>其中<code>[conditional-directive]</code>表示条件关键字，如”ifeq”。这个关键字有四个。</p>
<p>第一个是我们前面所见过的”ifeq”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifeq ([arg1], [arg2])</span><br><span class="line">ifeq &#39;[arg1]&#39; &#39;[arg2]&#39;</span><br><span class="line">ifeq &quot;[arg1]&quot; &quot;[arg2]&quot;</span><br><span class="line">ifeq &quot;[arg1]&quot; &#39;[arg2]&#39;</span><br><span class="line">ifeq &#39;[arg1]&#39; &quot;[arg2]&quot;</span><br></pre></td></tr></table></figure>
<p>比较参数”arg1”和”arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifeq ($(strip $(foo)),)</span><br><span class="line">    [text-if-empty]</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>这个示例中使用了”strip”函数，如果这个函数的返回值是空（Empty），那么[text-if-empty]就生效。</p>
<p>第二个条件关键字是”ifneq”。语法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifneq ([arg1], [arg2])</span><br><span class="line">ifneq &#39;[arg1]&#39; &#39;[arg2]&#39;</span><br><span class="line">ifneq &quot;[arg1]&quot; &quot;[arg2]&quot;</span><br><span class="line">ifneq &quot;[arg1]&quot; &#39;[arg2]&#39;</span><br><span class="line">ifneq &#39;[arg1]&#39; &quot;[arg2]&quot;</span><br></pre></td></tr></table></figure>
<p>其比较参数”arg1”和”arg2”的值是否相同，如果不同，则为真。和”ifeq”类似。</p>
<p>第三个条件关键字是”ifdef”。语法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifdef [variable-name]</span><br></pre></td></tr></table></figure>
<p>如果变量[variable-name]的值非空，那到表达式为真。否则，表达式为假。当然，[variable-name]同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：<br>示例一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bar &#x3D;</span><br><span class="line">foo &#x3D; $(bar)</span><br><span class="line">ifdef foo</span><br><span class="line">    frobozz &#x3D; yes</span><br><span class="line">else</span><br><span class="line">    frobozz &#x3D; no</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo &#x3D;</span><br><span class="line">ifdef foo</span><br><span class="line">    frobozz &#x3D; yes</span><br><span class="line">else</span><br><span class="line">    frobozz &#x3D; no</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>第一个例子中，”$(frobozz)”值是”yes”，第二个则是”no”。</p>
<p>第四个条件关键字是”ifndef”。其语法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifndef [variable-name]</span><br></pre></td></tr></table></figure>
<p>这个我就不多说了，和”ifdef”是相反的意思。</p>
<p>在<code>[conditional-directive]</code>这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符”#”同样也是安全的。”else”和”endif”也一样，只要不是以[Tab]键开始就行了。</p>
<p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如”$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。</p>
<p>而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。</p>
<h2 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h2><p>在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。</p>
<h3 id="函数的调用语法"><a href="#函数的调用语法" class="headerlink" title="函数的调用语法"></a>函数的调用语法</h3><p>函数调用，很像变量的使用，也是以”$”来标识的，其语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$([function] [arguments])</span><br></pre></td></tr></table></figure>
<p>或是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;[function] [arguments]&#125;</span><br></pre></td></tr></table></figure>
<p>这里，[function]就是函数名，make支持的函数不多。[arguments]是函数的参数，参数间以逗号”,”分隔，而函数名和参数之间以”空格”分隔。函数调用以”$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用”$(subst a,b,$(x))”这样的形式，而不是”$(subst a,b,${x})”的形式。因为统一会更清楚，也会减少一些不必要的麻烦。</p>
<p>还是来看一个示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comma:&#x3D; ,</span><br><span class="line">empty:&#x3D;</span><br><span class="line">space:&#x3D; $(empty) $(empty)</span><br><span class="line">foo:&#x3D; a b c</span><br><span class="line">bar:&#x3D; $(subst $(space),$(comma),$(foo))</span><br></pre></td></tr></table></figure>
<p>在这个示例中，$(comma)的值是一个逗号。$(space)使用了$(empty)定义了一个空格，$(foo)的值是”a b c”，$(bar)的定义用，调用了函数”subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把$(foo)中的空格替换成逗号，所以$(bar)的值是”a,b,c”。</p>
<h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(subst [from],[to],[text])</span><br></pre></td></tr></table></figure>
<p>名称：字符串替换函数——subst。<br>功能：把字串[text]中的[from]字符串替换成[to]。<br>返回：函数返回被替换过后的字符串。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(subst ee,EE,feet on the street)，</span><br><span class="line">&#96;&#96;&#96;        </span><br><span class="line">把&quot;feet on the street&quot;中的&quot;ee&quot;替换成&quot;EE&quot;，返回结果是&quot;fEEt on the strEEt&quot;。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;make</span><br><span class="line">$(patsubst [pattern],[replacement],[text])</span><br></pre></td></tr></table></figure>
<p>名称：模式字符串替换函数——patsubst。<br>功能：查找[text]中的单词（单词以”空格”、”Tab”或”回车””换行”分隔）是否符合模式[pattern]，如果匹配的话，则以[replacement]替换。这里，[pattern]可以包括通配符”%”，表示任意长度的字串。如果[replacement]中也包含”%”，那么，[replacement]中的这个”%”将是[pattern]中的那个”%”所代表的字串。（可以用”/“来转义，以”/%”来表示真实含义的”%”字符）<br>返回：函数返回被替换过后的字符串。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(patsubst %.c,%.o,x.c.c bar.c)</span><br></pre></td></tr></table></figure>
<p>把字串”x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是”x.c.o bar.o”<br>备注：这和我们前面”变量章节”说过的相关知识有点相似。如：”$(var:[pattern]=[replacement])”, 相当于”$(patsubst [pattern],[replacement],$(var))”，而”$(var: [suffix]=[replacement])”, 则相当于”$(patsubst %[suffix],%[replacement],$(var))”。<br>例如有：objects = foo.o bar.o baz.o，那么，”$(objects:.o=.c)”和”$(patsubst %.o,%.c,$(objects))”是一样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(strip [string])</span><br></pre></td></tr></table></figure>
<p>名称：去空格函数——strip。<br>功能：去掉[string]字串中开头和结尾的空字符。<br>返回：返回被去掉空格的字符串值。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(strip a b c )</span><br></pre></td></tr></table></figure>
<p>把字串”a b c “去到开头和结尾的空格，结果是”a b c”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(findstring [find],[in])</span><br></pre></td></tr></table></figure>
<p>名称：查找字符串函数——findstring。<br>功能：在字串[in]中查找[find]字串。<br>返回：如果找到，那么返回[find]，否则返回空字符串。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(findstring a,a b c)</span><br><span class="line">$(findstring a,b c)</span><br></pre></td></tr></table></figure>
<p>第一个函数返回”a”字符串，第二个返回””字符串（空字符串）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(filter [pattern...],[text])</span><br></pre></td></tr></table></figure>
<p>名称：过滤函数——filter。<br>功能：以[pattern]模式过滤[text]字符串中的单词，保留符合模式[pattern]的单词。可以有多个模式。<br>返回：返回符合模式[pattern]的字串。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sources :&#x3D; foo.c bar.c baz.s ugh.h</span><br><span class="line">foo: $(sources)</span><br><span class="line">    cc $(filter %.c %.s,$(sources)) -o foo</span><br><span class="line"></span><br><span class="line">$(filter %.c %.s,$(sources))</span><br></pre></td></tr></table></figure>
<p>返回的值是”foo.c bar.c baz.s”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(filter-out [pattern...],[text])</span><br></pre></td></tr></table></figure>
<p>名称：反过滤函数——filter-out。<br>功能：以[pattern]模式过滤[text]字符串中的单词，去除符合模式[pattern]的单词。可以有多个模式。<br>返回：返回不符合模式[pattern]的字串。<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects&#x3D;main1.o foo.o main2.o bar.o</span><br><span class="line">mains&#x3D;main1.o main2.o</span><br><span class="line"></span><br><span class="line">$(filter-out $(mains),$(objects))</span><br></pre></td></tr></table></figure>
<p>返回值是”foo.o bar.o”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(sort [list])</span><br></pre></td></tr></table></figure>
<p>名称：排序函数——sort。<br>功能：给字符串[list]中的单词排序（升序）。<br>返回：返回排序后的字符串。<br>示例：$(sort foo bar lose)返回”bar foo lose” 。<br>备注：sort函数会去掉[list]中相同的单词。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(word [n],[text])</span><br></pre></td></tr></table></figure>
<p>名称：取单词函数——word。<br>功能：取字符串[text]中第[n]个单词。（从一开始）<br>返回：返回字符串[text]中第[n]个单词。如果[n]比[text]中的单词数要大，那么返回空字符串。<br>示例：$(word 2, foo bar baz)返回值是”bar”。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(wordlist [s],[e],[text])</span><br></pre></td></tr></table></figure>
<p>名称：取单词串函数——wordlist。<br>功能：从字符串[text]中取从[s]开始到[e]的单词串。[s]和[e]是一个数字。<br>返回：返回字符串[text]中从[s]到[e]的单词字串。如果[s]比[text]中的单词数要大，那么返回空字符串。如果[e]大于[text]的单词数，那么返回从[s]开始，到[text]结束的单词串。<br>示例： $(wordlist 2, 3, foo bar baz)返回值是”bar baz”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(words [text])</span><br></pre></td></tr></table></figure>
<p>名称：单词个数统计函数——words。<br>功能：统计[text]中字符串中的单词个数。<br>返回：返回[text]中的单词数。<br>示例：$(words, foo bar baz)返回值是”3”。<br>备注：如果我们要取[text]中最后的一个单词，我们可以这样：$(word $(words [text]),[text])。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(firstword [text])</span><br></pre></td></tr></table></figure>
<p>名称：首单词函数——firstword。<br>功能：取字符串[text]中的第一个单词。<br>返回：返回字符串[text]的第一个单词。<br>示例：$(firstword foo bar)返回值是”foo”。<br>备注：这个函数可以用word函数来实现：$(word 1,[text])。</p>
<p>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用”VPATH”变量来指定”依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override CFLAGS +&#x3D; $(patsubst %,-I%,$(subst :, ,$(VPATH)))</span><br></pre></td></tr></table></figure>
<p>如果我们的”$(VPATH)”值是”src:../headers”，那么”$(patsubst %,-I%,$(subst :, ,$(VPATH)))”将返回”-Isrc -I../headers”，这正是cc或gcc搜索头文件路径的参数。</p>
<h3 id="文件名操作函数"><a href="#文件名操作函数" class="headerlink" title="文件名操作函数"></a>文件名操作函数</h3><p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(dir [names...])</span><br></pre></td></tr></table></figure>
<p>名称：取目录函数——dir。<br>功能：从文件名序列[names]中取出目录部分。目录部分是指最后一个反斜杠（”/“）之前的部分。如果没有反斜杠，那么返回”./“。<br>返回：返回文件名序列[names]的目录部分。<br>示例： $(dir src/foo.c hacks)返回值是”src/ ./“。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(notdir [names...])</span><br></pre></td></tr></table></figure>
<p>名称：取文件函数——notdir。<br>功能：从文件名序列[names]中取出非目录部分。非目录部分是指最后一个反斜杠（”/“）之后的部分。<br>返回：返回文件名序列[names]的非目录部分。<br>示例： $(notdir src/foo.c hacks)返回值是”foo.c hacks”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(suffix [names...])</span><br></pre></td></tr></table></figure>
<p>名称：取后缀函数——suffix。<br>功能：从文件名序列[names]中取出各个文件名的后缀。<br>返回：返回文件名序列[names]的后缀序列，如果文件没有后缀，则返回空字串。<br>示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是”.c .c”。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(basename [names...])</span><br></pre></td></tr></table></figure>
<p>名称：取前缀函数——basename。<br>功能：从文件名序列[names]中取出各个文件名的前缀部分。<br>返回：返回文件名序列[names]的前缀序列，如果文件没有前缀，则返回空字串。<br>示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是”src/foo src-1.0/bar hacks”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(addsuffix [suffix],[names...])</span><br></pre></td></tr></table></figure>
<p>名称：加后缀函数——addsuffix。<br>功能：把后缀[suffix]加到[names]中的每个单词后面。<br>返回：返回加过后缀的文件名序列。<br>示例：$(addsuffix .c,foo bar)返回值是”foo.c bar.c”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(addprefix [prefix],[names...])</span><br></pre></td></tr></table></figure>
<p>名称：加前缀函数——addprefix。<br>功能：把前缀[prefix]加到[names]中的每个单词后面。<br>返回：返回加过前缀的文件名序列。<br>示例：$(addprefix src/,foo bar)返回值是”src/foo src/bar”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(join [list1],[list2])</span><br></pre></td></tr></table></figure>
<p>名称：连接函数——join。<br>功能：把[list2]中的单词对应地加到[list1]的单词后面。如果[list1]的单词个数要比[list2]的多，那么，[list1]中的多出来的单词将保持原样。如果[list2]的单词个数要比[list1]多，那么，[list2]多出来的单词将被复制到[list2]中。<br>返回：返回连接过后的字符串。<br>示例：$(join aaa bbb , 111 222 333)返回值是”aaa111 bbb222 333”。</p>
<h3 id="foreach-函数"><a href="#foreach-函数" class="headerlink" title="foreach 函数"></a>foreach 函数</h3><p>foreach函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的foreach函数几乎是仿照于Unix标准Shell（/bin/sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是：<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(foreach [var],[list],[text])</span><br></pre></td></tr></table></figure><br>这个函数的意思是，把参数[list]中的单词逐一取出放到参数[var]所指定的变量中，然后再执行[text]所包含的表达式。每一次[text]会返回一个字符串，循环过程中，[text]的所返回的每个字符串会以空格分隔，最后当整个循环结束时，[text]所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</p>
<p>所以，[var]最好是一个变量名，[list]可以是一个表达式，而[text]中一般会使用[var]这个参数来依次枚举[list]中的单词。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">names :&#x3D; a b c d</span><br><span class="line">files :&#x3D; $(foreach n,$(names),$(n).o)</span><br></pre></td></tr></table></figure>
<p>上面的例子中，$(name)中的单词会被挨个取出，并存到变量”n”中，”$(n).o”每次根据”$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(files)的值是”a.o b.o c.o d.o”。</p>
<p>注意，foreach中的[var]参数是一个临时的局部变量，foreach函数执行完后，参数[var]的变量将不在作用，其作用域只在foreach函数当中。</p>
<h3 id="if-函数"><a href="#if-函数" class="headerlink" title="if 函数"></a>if 函数</h3><p>if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(if [condition],[then-part])</span><br></pre></td></tr></table></figure><br>或是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(if [condition],[then-part],[else-part])</span><br></pre></td></tr></table></figure>
<p>可见，if函数可以包含”else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。[condition]参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，[then-part]会被计算，否则[else-part]会被计算。</p>
<p>而if函数的返回值是，如果[condition]为真（非空字符串），那个[then-part]会是整个函数的返回值，如果[condition]为假（空字符串），那么[else-part]会是整个函数的返回值，此时如果[else-part]没有被定义，那么，整个函数返回空字串。</p>
<p>所以，[then-part]和[else-part]只会有一个被计算。</p>
<h3 id="call函数"><a href="#call函数" class="headerlink" title="call函数"></a>call函数</h3><p>call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(call [expression],[parm1],[parm2],[parm3]...)</span><br></pre></td></tr></table></figure>
<p>当make执行这个函数时，[expression]参数中的变量，如$(1)，$(2)，$(3)等，会被参数[parm1]，[parm2]，[parm3]依次取代。而[expression]的返回值就是call函数的返回值。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reverse &#x3D;  $(1) $(2)</span><br><span class="line">foo &#x3D; $(call reverse,a,b)</span><br></pre></td></tr></table></figure>
<p>那么，foo的值就是”a b”。当然，参数的次序是可以自定义的，不一定是顺序的，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reverse &#x3D;  $(2) $(1)</span><br><span class="line">foo &#x3D; $(call reverse,a,b)</span><br></pre></td></tr></table></figure>
<p>此时的foo的值就是”b a”。</p>
<h3 id="origin函数"><a href="#origin函数" class="headerlink" title="origin函数"></a>origin函数</h3><p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(origin [variable])</span><br></pre></td></tr></table></figure>
<p>注意，[variable]是变量的名字，不应该是引用。所以你最好不要在[variable]中使用”$”字符。Origin函数会以其返回值来告诉你这个变量的”出生情况”，下面，是origin函数的返回值:  </p>
<ul>
<li>“undefined” 如果[variable]从来没有定义过，origin函数返回这个值”undefined”。</li>
<li>“default” 如果[variable]是一个默认的定义，比如”CC”这个变量，这种变量我们将在后面讲述。</li>
<li>“environment” 如果[variable]是一个环境变量，并且当Makefile被执行时，”-e”参数没有被打开。</li>
<li>“file” 如果[variable]这个变量被定义在Makefile中。</li>
<li>“command line” 如果[variable]这个变量是被命令行定义的。</li>
<li>“override” 如果[variable]是被override指示符重新定义的。</li>
<li>“automatic” 如果[variable]是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</li>
</ul>
<p>这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量”bletch”，而我们的环境中也有一个环境变量”bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifdef bletch</span><br><span class="line">    ifeq &quot;$(origin bletch)&quot; &quot;environment&quot;</span><br><span class="line">        bletch &#x3D; barf, gag, etc.</span><br><span class="line">    endif</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是override过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。</p>
<h3 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h3><p>shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号”`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contents :&#x3D; $(shell cat foo)</span><br><span class="line"></span><br><span class="line">files :&#x3D; $(shell echo *.c)</span><br></pre></td></tr></table></figure>
<p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>
<h3 id="控制make的函数"><a href="#控制make的函数" class="headerlink" title="控制make的函数"></a>控制make的函数</h3><p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(error [text ...])</span><br></pre></td></tr></table></figure>
<p>产生一个致命的错误，[text …]是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：<br>示例一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifdef ERROR_001</span><br><span class="line">    $(error error is $(ERROR_001))</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERR &#x3D; $(error found an error!)</span><br><span class="line">.PHONY: err</span><br><span class="line">err: ; $(ERR)</span><br></pre></td></tr></table></figure>
<p>示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(warning [text ...])</span><br></pre></td></tr></table></figure>
<p>这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。</p>
<h2 id="make-的运行"><a href="#make-的运行" class="headerlink" title="make 的运行"></a>make 的运行</h2><p>一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。</p>
<h3 id="make的退出码"><a href="#make的退出码" class="headerlink" title="make的退出码"></a>make的退出码</h3><p>make命令执行后有三个退出码：<br>＋ 0 —— 表示成功执行。<br>＋ 1 —— 如果make运行时出现任何错误，其返回1。<br>＋ 2 —— 如果你使用了make的”-q”选项，并且make使得一些目标不需要更新，那么返回2。</p>
<p>Make的相关参数我们会在后续章节中讲述。</p>
<h3 id="指定Makefile"><a href="#指定Makefile" class="headerlink" title="指定Makefile"></a>指定Makefile</h3><p>前面我们说过，GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、”makefile”和”Makefile”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。</p>
<p>当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的”-f”或是”–file”参数（”–makefile”参数也行）。例如，我们有个makefile的名字是”hchen.mk”，那么，我们可以这样来让make来执行这个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make –f hchen.mk</span><br></pre></td></tr></table></figure>
<p>如果在make的命令行是，你不只一次地使用了”-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。</p>
<h3 id="指定目标"><a href="#指定目标" class="headerlink" title="指定目标"></a>指定目标</h3><p>一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的”make clean”形式）</p>
<p>任何在makefile中的目标都可以被指定成终极目标，但是除了以”-“打头，或是包含了”=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。</p>
<p>有一个make的环境变量叫”MAKECMDGOALS”，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sources &#x3D; foo.c bar.c</span><br><span class="line">ifneq ( $(MAKECMDGOALS),clean)</span><br><span class="line">    include $(sources:.c&#x3D;.d)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>基于上面的这个例子，只要我们输入的命令不是”make clean”，那么makefile会自动包含”foo.d”和”bar.d”这两个makefile。</p>
<p>使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">all: prog1 prog2 prog3 prog4</span><br></pre></td></tr></table></figure>
<p>从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序——“prog1”， “prog2”， “prog3”和 “prog4”，我们可以使用”make all”命令来编译所有的目标（如果把all置成第一个目标，那么只需执行”make”），我们也可以使用”make prog2”来单独编译目标”prog2”。</p>
<p>即然make可以指定所有makefile中的目标，那么也包括”伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。</p>
<ul>
<li>“all” 这个伪目标是所有目标的目标，其功能一般是编译所有的目标。</li>
<li>“clean” 这个伪目标功能是删除所有被make创建的文件。</li>
<li>“install” 这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。</li>
<li>“print” 这个伪目标的功能是例出改变过的源文件。</li>
<li>“tar” 这个伪目标功能是把源程序打包备份。也就是一个tar文件。</li>
<li>“dist” 这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。</li>
<li>“TAGS” 这个伪目标功能是更新所有的目标，以备完整地重编译使用。</li>
<li>“check”和”test” 这两个伪目标一般用来测试makefile的流程。</li>
</ul>
<p>当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。</p>
<h3 id="检查规则"><a href="#检查规则" class="headerlink" title="检查规则"></a>检查规则</h3><p>有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：<br>“-n”<br>“–just-print”<br>“–dry-run”<br>“–recon”<br>不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。</p>
<p>“-t”<br>“–touch”<br>这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</p>
<p>“-q”<br>“–question”<br>这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。</p>
<p>“-W [file]”<br>“–what-if=[file]”<br>“–assume-new=[file]”<br>“–new-file=[file]”<br>这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和”-n”参数一同使用，来查看这个依赖文件所发生的规则命令。</p>
<p>另外一个很有意思的用法是结合”-p”和”-v”来输出makefile被执行时的信息（这个将在后面讲述）。</p>
<h3 id="make的参数"><a href="#make的参数" class="headerlink" title="make的参数"></a>make的参数</h3><p>下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。</p>
<p>“-b”<br>“-m”<br>这两个参数的作用是忽略和其它版本make的兼容性。</p>
<p>“-B”<br>“–always-make”<br>认为所有的目标都需要更新（重编译）。</p>
<p>“-C [dir]”<br>“–directory=[dir]”<br>指定读取makefile的目录。如果有多个”-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：”make –C ~hchen/test –C prog”等价于”make –C ~hchen/test/prog”。</p>
<p>“—debug[=[options]]”<br>输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是[options]的取值：</p>
<ul>
<li>a —— 也就是all，输出所有的调试信息。（会非常的多）</li>
<li>b —— 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。</li>
<li>v —— 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。</li>
<li>i —— 也就是implicit，输出所以的隐含规则。</li>
<li>j —— 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。</li>
<li>m —— 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。</li>
</ul>
<p>“-d”<br>相当于”–debug=a”。</p>
<p>“-e”<br>“–environment-overrides”<br>指明环境变量的值覆盖makefile中定义的变量的值。</p>
<p>“-f=[file]”<br>“–file=[file]”<br>“–makefile=[file]”<br>指定需要执行的makefile。</p>
<p>“-h”<br>“–help”<br>显示帮助信息。</p>
<p>“-i”<br>“–ignore-errors”<br>在执行时忽略所有的错误。</p>
<p>“-I [dir]”<br>“–include-dir=[dir]”<br>指定一个被包含makefile的搜索目标。可以使用多个”-I”参数来指定多个目录。</p>
<p>“-j [[jobsnum]]”<br>“–jobs[=[jobsnum]]”<br>指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的”-j”参数，那么仅最后一个”-j”才是有效的。（注意这个参数在MS-DOS中是无用的）</p>
<p>“-k”<br>“–keep-going”<br>出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。</p>
<p>“-l [load]”<br>“–load-average[=[load]”<br>“—max-load[=[load]]”<br>指定make运行命令的负载。</p>
<p>“-n”<br>“–just-print”<br>“–dry-run”<br>“–recon”<br>仅输出执行过程中的命令序列，但并不执行。</p>
<p>“-o [file]”<br>“–old-file=[file]”<br>“–assume-old=[file]”<br>不重新生成的指定的[file]，即使这个目标的依赖文件新于它。</p>
<p>“-p”<br>“–print-data-base”<br>输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行makefile，你可以使用”make -qp”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用”make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。</p>
<p>“-q”<br>“–question”<br>不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。</p>
<p>“-r”<br>“–no-builtin-rules”<br>禁止make使用任何隐含规则。</p>
<p>“-R”<br>“–no-builtin-variabes”<br>禁止make使用任何作用于变量上的隐含规则。</p>
<p>“-s”<br>“–silent”<br>“–quiet”<br>在命令运行时不输出命令的输出。</p>
<p>“-S”<br>“–no-keep-going”<br>“–stop”<br>取消”-k”选项的作用。因为有些时候，make的选项是从环境变量”MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的”-k”选项失效。</p>
<p>“-t”<br>“–touch”<br>相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。</p>
<p>“-v”<br>“–version”<br>输出make程序的版本、版权等关于make的信息。</p>
<p>“-w”<br>“–print-directory”<br>输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。</p>
<p>“–no-print-directory”<br>禁止”-w”选项。</p>
<p>“-W [file]”<br>“–what-if=[file]”<br>“–new-file=[file]”<br>“–assume-file=[file]”<br>假定目标[file]需要更新，如果和”-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有”-n”那么就像运行UNIX的”touch”命令一样，使得[file]的修改时间为当前时间。</p>
<p>“–warn-undefined-variables”<br>只要make发现有未定义的变量，那么就输出警告信息。</p>
<h2 id="隐含规则"><a href="#隐含规则" class="headerlink" title="隐含规则"></a>隐含规则</h2><p>在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o]文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的”隐含的”，早先约定了的，不需要我们再写出来的规则。</p>
<p>“隐含规则”也就是一种惯例，make会按照这种”惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。</p>
<p>“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量”CFLAGS”可以控制编译时的编译器参数。</p>
<p>我们还可以通过”模式规则”的方式写下自己的隐含规则。用”后缀规则”来定义隐含规则会有许多的限制。使用”模式规则”会更回得智能和清楚，但”后缀规则”可以用来保证我们Makefile的兼容性。<br>我们了解了”隐含规则”，可以让其为我们更好的服务，也会让我们知道一些”约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候”隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。</p>
<h3 id="使用隐含规则"><a href="#使用隐含规则" class="headerlink" title="使用隐含规则"></a>使用隐含规则</h3><p>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo: foo.o bar.o</span><br><span class="line">    cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)</span><br></pre></td></tr></table></figure>
<p>我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的”隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。</p>
<p>make会在自己的”隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把[.o]的目标的依赖文件置成[.c]，并使用C的编译命令”cc –c $(CFLAGS) [.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo.o: foo.c</span><br><span class="line">    cc –c foo.c $(CFLAGS)</span><br><span class="line">bar.o: bar.c</span><br><span class="line">    cc –c bar.c $(CFLAGS)</span><br></pre></td></tr></table></figure>
<p>因为，这已经是”约定”好了的事了，make和我们约定好了用C编译器”cc”生成[.o]文件的规则，这就是隐含规则。</p>
<p>当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。</p>
<p>还有，在make的”隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo.o: foo.p</span><br></pre></td></tr></table></figure>
<p>依赖文件”foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了”foo.c”文件，那么我们的隐含规则一样会生效，并会通过”foo.c”调用C的编译器生成foo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出”依赖规则”，而不写命令。</p>
<h3 id="隐含规则一览"><a href="#隐含规则一览" class="headerlink" title="隐含规则一览"></a>隐含规则一览</h3><p>这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数”-r”或”–no-builtin-rules”选项来取消所有的预设置的隐含规则。</p>
<p>当然，即使是我们指定了”-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了”后缀规则”来定义的，所以，只要隐含规则中有”后缀列表”（也就一系统定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。具体的细节，我们会在后面讲述。</p>
<p>还是先来看一看常用的隐含规则吧。</p>
<ol>
<li><p>编译C程序的隐含规则。”[n].o”的目标的依赖目标会自动推导为”[n].c”，并且其生成命令是”$(CC) –c $(CPPFLAGS) $(CFLAGS)”</p>
</li>
<li><p>编译C++程序的隐含规则。”[n].o”的目标的依赖目标会自动推导为”[n].cc”或是”[n].C”，并且其生成命令是”$(CXX) –c $(CPPFLAGS) $(CFLAGS)”。（建议使用”.cc”作为C++源文件的后缀，而不是”.C”）</p>
</li>
<li><p>编译Pascal程序的隐含规则。”[n].o”的目标的依赖目标会自动推导为”[n].p”，并且其生成命令是”$(PC) –c  $(PFLAGS)”。</p>
</li>
<li><p>编译Fortran/Ratfor程序的隐含规则。”[n].o”的目标的依赖目标会自动推导为”[n].r”或”[n].F”或”[n].f”，并且其生成命令是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;.f&quot;  &quot;$(FC) –c  $(FFLAGS)&quot;</span><br><span class="line">&quot;.F&quot;  &quot;$(FC) –c  $(FFLAGS) $(CPPFLAGS)&quot;</span><br><span class="line">&quot;.f&quot;  &quot;$(FC) –c  $(FFLAGS) $(RFLAGS)&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>预处理Fortran/Ratfor程序的隐含规则。”[n].f”的目标的依赖目标会自动推导为”[n].r”或”[n].F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;.F&quot;  &quot;$(FC) –F $(CPPFLAGS) $(FFLAGS)&quot;</span><br><span class="line">&quot;.r&quot;  &quot;$(FC) –F $(FFLAGS) $(RFLAGS)&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译Modula-2程序的隐含规则。”[n].sym”的目标的依赖目标会自动推导为”[n].def”，并且其生成命令是：”$(M2C) $(M2FLAGS) $(DEFFLAGS)”。”[n.o]” 的目标的依赖目标会自动推导为”[n].mod”，并且其生成命令是：”$(M2C) $(M2FLAGS) $(MODFLAGS)”。</p>
</li>
<li><p>汇编和汇编预处理的隐含规则。”[n].o” 的目标的依赖目标会自动推导为”[n].s”，默认使用编译品”as”，并且其生成命令是：”$(AS) $(ASFLAGS)”。”[n].s” 的目标的依赖目标会自动推导为”[n].S”，默认使用C预编译器”cpp”，并且其生成命令是：”$(AS) $(ASFLAGS)”。</p>
</li>
<li><p>链接Object文件的隐含规则。”[n]”目标依赖于”[n].o”，通过运行C的编译器来运行链接程序生成（一般是”ld”），其生成命令是：”$(CC) $(LDFLAGS) [n].o $(LOADLIBES) $(LDLIBS)”。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x: y.o z.o</span><br></pre></td></tr></table></figure>
<p>并且”x.c”、”y.c”和”z.c”都存在时，隐含规则将执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc -c x.c -o x.o</span><br><span class="line">cc -c y.c -o y.o</span><br><span class="line">cc -c z.c -o z.o</span><br><span class="line">cc x.o y.o z.o -o x</span><br><span class="line">rm -f x.o</span><br><span class="line">rm -f y.o</span><br><span class="line">rm -f z.o</span><br></pre></td></tr></table></figure>
<p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>
</li>
<li><p>Yacc C程序时的隐含规则。”[n].c”的依赖文件被自动推导为”n.y”（Yacc生成的文件），其生成命令是：”$(YACC) $(YFALGS)”。（”Yacc”是一个语法分析器，关于其细节请查看相关资料）</p>
</li>
<li><p>Lex C程序时的隐含规则。”[n].c”的依赖文件被自动推导为”n.l”（Lex生成的文件），其生成命令是：”$(LEX) $(LFALGS)”。（关于”Lex”的细节请查看相关资料）</p>
</li>
<li><p>Lex Ratfor程序时的隐含规则。”[n].r”的依赖文件被自动推导为”n.l”（Lex生成的文件），其生成命令是：”$(LEX) $(LFALGS)”。</p>
</li>
<li><p>从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。”[n].ln” （lint生成的文件）的依赖文件被自动推导为”n.c”，其生成命令是：”$(LINT) $(LINTFALGS) $(CPPFLAGS) -i”。对于”[n].y”和”[n].l”也是同样的规则。</p>
</li>
</ol>
<h3 id="隐含规则使用的变量"><a href="#隐含规则使用的变量" class="headerlink" title="隐含规则使用的变量"></a>隐含规则使用的变量</h3><p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的”-R”或”–no–builtin-variables”参数来取消你所定义的变量对隐含规则的作用。</p>
<p>例如，第一条隐含规则——编译C程序的隐含规则的命令是”$(CC) –c $(CFLAGS) $(CPPFLAGS)”。Make默认的编译命令是”cc”，如果你把变量”$(CC)”重定义成”gcc”，把变量”$(CFLAGS)”重定义成”-g”，那么，隐含规则中的命令全部会以”gcc –c -g $(CPPFLAGS)”的样子来执行了。</p>
<p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如”CC”；一种是参数相的关，如”CFLAGS”。下面是所有隐含规则中会用到的变量：</p>
<p>1、关于命令的变量。</p>
<ul>
<li>AR 函数库打包程序。默认命令是”ar”。</li>
<li>AS 汇编语言编译程序。默认命令是”as”。</li>
<li>CC C语言编译程序。默认命令是”cc”。</li>
<li>CXX C++语言编译程序。默认命令是”g++”。</li>
<li>CO 从 RCS文件中扩展文件程序。默认命令是”co”。</li>
<li>CPP C程序的预处理器（输出是标准输出设备）。默认命令是”$(CC) –E”。</li>
<li>FC Fortran 和 Ratfor 的编译器和预处理程序。默认命令是”f77”。</li>
<li>GET 从SCCS文件中扩展文件的程序。默认命令是”get”。</li>
<li>LEX Lex方法分析器程序（针对于C或Ratfor）。默认命令是”lex”。</li>
<li>PC Pascal语言编译程序。默认命令是”pc”。</li>
<li>YACC Yacc文法分析器（针对于C程序）。默认命令是”yacc”。</li>
<li>YACCR Yacc文法分析器（针对于Ratfor程序）。默认命令是”yacc –r”。</li>
<li>MAKEINFO 转换Texinfo源文件（.texi）到Info文件程序。默认命令是”makeinfo”。</li>
<li>TEX 从TeX源文件创建TeX DVI文件的程序。默认命令是”tex”。</li>
<li>TEXI2DVI 从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是”texi2dvi”。</li>
<li>WEAVE 转换Web到TeX的程序。默认命令是”weave”。</li>
<li>CWEAVE 转换C Web 到 TeX的程序。默认命令是”cweave”。</li>
<li>TANGLE 转换Web到Pascal语言的程序。默认命令是”tangle”。</li>
<li>CTANGLE 转换C Web 到 C。默认命令是”ctangle”。</li>
<li>RM 删除文件命令。默认命令是”rm –f”。</li>
</ul>
<p>2、关于命令参数的变量</p>
<p>下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。</p>
<ul>
<li>ARFLAGS 函数库打包程序AR命令的参数。默认值是”rv”。</li>
<li>ASFLAGS 汇编语言编译器参数。（当明显地调用”.s”或”.S”文件时）。</li>
<li>CFLAGS C语言编译器参数。</li>
<li>CXXFLAGS C++语言编译器参数。</li>
<li>COFLAGS RCS命令参数。</li>
<li>CPPFLAGS C预处理器参数。（ C 和 Fortran 编译器也会用到）。</li>
<li>FFLAGS Fortran语言编译器参数。</li>
<li>GFLAGS SCCS “get”程序参数。</li>
<li>LDFLAGS 链接器参数。（如：”ld”）</li>
<li>LFLAGS Lex文法分析器参数。</li>
<li>PFLAGS Pascal语言编译器参数。</li>
<li>RFLAGS Ratfor 程序的Fortran 编译器参数。</li>
<li>YFLAGS Yacc文法分析器参数。</li>
</ul>
<h3 id="隐含规则链"><a href="#隐含规则链" class="headerlink" title="隐含规则链"></a>隐含规则链</h3><p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则叫做”隐含规则链”。</p>
<p>在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。</p>
<p>我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？</p>
<p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以”rm -f”删除。</p>
<p>通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标”.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE ： mid ）</p>
<p>你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标”.SECONDARY”来强制声明（如：.SECONDARY: sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标”.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。</p>
<p>在”隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p>
<p>Make会优化一些特殊的隐含规则，而不生成中间文件。如，从文件”foo.c”生成目标程序”foo”，按道理，make会编译生成中间文件”foo.o”，然后链接成”foo”，但在实际情况下，这一动作可以被一条”cc”的命令完成（cc –o foo foo.c），于是优化过的规则就不会生成中间文件。</p>
<h3 id="定义模式规则"><a href="#定义模式规则" class="headerlink" title="定义模式规则"></a>定义模式规则</h3><p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有”%”字符。”%”的意思是表示一个或多个任意字符。在依赖目标中同样可以使用”%”，只是依赖目标中的”%”的取值，取决于其目标。</p>
<p>有一点需要注意的是，”%”的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的”%”则发生在运行时。</p>
<p>1、模式规则介绍</p>
<p>模式规则中，至少在规则的目标定义中要包含”%”，否则，就是一般的规则。目标中的”%”定义表示对文件名的匹配，”%”表示长度任意的非空字符串。例如：”%.c”表示以”.c”结尾的文件名（文件名的长度至少为3），而”s.%.c”则表示以”s.”开头，”.c”结尾的文件名（文件名的长度至少为5）。</p>
<p>如果”%”定义在目标中，那么，目标中的”%”的值决定了依赖目标中的”%”的值，也就是说，目标中的模式的”%”决定了依赖目标中”%”的样子。例如有一个模式规则如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%.o: %.c ; [command ......]</span><br></pre></td></tr></table></figure>
<p>其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是”a.o b.o”，那么”%c”就是”a.c b.c”。</p>
<p>一旦依赖目标中的”%”模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。</p>
<p>2、模式规则示例</p>
<p>下面这个例子表示了,把所有的[.c]文件都编译成[.o]文件.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%.o: %.c</span><br><span class="line">    $(CC) -c $(CFLAGS) $(CPPFLAGS) $[ -o $@</span><br></pre></td></tr></table></figure>
<p>其中，”$@”表示所有的目标的挨个值，”$[“表示了所有依赖目标的挨个值。这些奇怪的变量我们叫”自动化变量”，后面会详细讲述。</p>
<p>下面的这个例子中有两个目标是模式的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%.tab.c %.tab.h: %.y</span><br><span class="line">    bison -d $[</span><br></pre></td></tr></table></figure>
<p>这条规则告诉make把所有的[.y]文件都以”bison -d [n].y”执行，然后生成”[n].tab.c”和”[n].tab.h”文件。（其中，”[n]”表示一个任意字符串）。如果我们的执行程序”foo”依赖于文件”parse.tab.o”和”scan.o”，并且文件”scan.o”依赖于文件”parse.tab.h”，如果”parse.y”文件被更新了，那么根据上述的规则，”bison -d parse.y”就会被执行一次，于是，”parse.tab.o”和”scan.o”的依赖文件就齐了。（假设，”parse.tab.o”由”parse.tab.c”生成，和”scan.o”由”scan.c”生成，而”foo”由”parse.tab.o”和”scan.o”链接生成，而且foo和其[.o]文件的依赖关系也写好，那么，所有的目标都会得到满足）</p>
<p>3、自动化变量</p>
<p>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p>
<p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p>
<p>下面是所有的自动化变量及其说明：</p>
<ul>
<li>$@ 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，”$@”就是匹配于目标中模式定义的集合。</li>
<li>$% 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是”foo.a(bar.o)”，那么，”$%”就是”bar.o”，”$@”就是”foo.a”。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。</li>
<li>$[ 依赖目标中的第一个目标名字。如果依赖目标是以模式（即”%”）定义的，那么”$[“将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</li>
<li>$? 所有比目标新的依赖目标的集合。以空格分隔。</li>
<li>$^ 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</li>
<li>$+ 这个变量很像”$^”，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</li>
<li>$* 这个变量表示目标模式中”%”及其之前的部分。如果目标是”dir/a.foo.b”，并且目标的模式是”a.%.b”，那么，”$<em>“的值就是”dir/a.foo”。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么”$</em>“也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么”$<em>“就是除了后缀的那一部分。例如：如果目标是”foo.c”，因为”.c”是make所能识别的后缀名，所以，”$</em>“的值就是”foo”。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用”$<em>“，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么”$</em>“就是空值。</li>
</ul>
<p>当你希望只对更新过的依赖文件进行操作时，”$?”在显式规则中很有用，例如，假设有一个函数库文件叫”lib”，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lib: foo.o bar.o lose.o win.o</span><br><span class="line">    ar r lib $?</span><br></pre></td></tr></table></figure>
<p>在上述所列出来的自动量变量中。四个变量（$@、$[、$%、$*）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上”D”或”F”字样。这是GNU make中老版本的特性，在新版本中，我们使用函数”dir”或”notdir”就可以做到了。”D”的含义就是Directory，就是目录，”F”的含义就是File，就是文件。</p>
<p>下面是对于上面的七个变量分别加上”D”或是”F”的含义：</p>
<ul>
<li>$(@D) 表示”$@”的目录部分（不以斜杠作为结尾），如果”$@”值是”dir/foo.o”，那么”$(@D)”就是”dir”，而如果”$@”中没有包含斜杠的话，其值就是”.”（当前目录）。</li>
<li>$(@F) 表示”$@”的文件部分，如果”$@”值是”dir/foo.o”，那么”$(@F)”就是”foo.o”，”$(@F)”相当于函数”$(notdir $@)”。</li>
<li>“$(*D)” “$(*F)” 和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，”$(*D)”返回”dir”，而”$(*F)”返回”foo”</li>
<li>“$(%D)” “$(%F)” 分别表示了函数包文件成员的目录部分和文件部分。这对于形同”archive(member)”形式的目标中的”member”中包含了不同的目录很有用。</li>
<li>“$([D)” “$([F)” 分别表示依赖文件的目录部分和文件部分。</li>
<li>“$(^D)” “$(^F)” 分别表示所有依赖文件的目录部分和文件部分。（无相同的）</li>
<li>“$(+D)” “$(+F)” 分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</li>
<li>“$(?D)” “$(?F)” 分别表示被更新的依赖文件的目录部分和文件部分。</li>
</ul>
<p>最后想提醒一下的是，对于”$[“，为了避免产生不必要的麻烦，我们最好给$后面的那个特定字符都加上圆括号，比如，”$([)”就要比”$[“要好一些。</p>
<p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是”显式规则”和”静态模式规则”（参见前面”书写规则”一章）。其在隐含规则中并没有意义。</p>
<p>4、模式的匹配</p>
<p>一般来说，一个目标的模式有一个有前缀或是后缀的”%”，或是没有前后缀，直接就是一个”%”。因为”%”代表一个或多个字符，所以在定义好了的模式中，我们把”%”所匹配的内容叫做”茎”，例如”%.c”所匹配的文件”test.c”中”test”就是”茎”。因为在目标和依赖目标中同时有”%”时，依赖目标的”茎”会传给目标，当做目标中的”茎”。</p>
<p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行”茎”的传递时，我们需要知道这个步骤。例如有一个模式”e%t”，文件”src/eat”匹配于该模式，于是”src/a”就是其”茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式”c%r”，那么，目标就是”src/car”。（”茎”被传递）</p>
<p>5、重载内建隐含规则</p>
<p>你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%.o: %.c</span><br><span class="line">    $(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date)</span><br></pre></td></tr></table></figure>
<p>你可以取消内建的隐含规则，只要不在后面写命令就行。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%.o: %.s</span><br></pre></td></tr></table></figure>
<p>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p>
<h3 id="老式风格的”后缀规则”"><a href="#老式风格的”后缀规则”" class="headerlink" title="老式风格的”后缀规则”"></a>老式风格的”后缀规则”</h3><p>后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：”双后缀”和”单后缀”。</p>
<p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如”.c.o”相当于”%o: %c”。单后缀规则只定义一个后缀，也就是源文件的后缀。如”.c”相当于”%: %.c”。</p>
<p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：”.c”和”.o”都是make所知道。因而，如果你定义了一个规则是”.c.o”那么其就是双后缀规则，意义就是”.c”是源文件的后缀，”.o”是目标文件的后缀。如下示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.c.o:</span><br><span class="line">    $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $[</span><br></pre></td></tr></table></figure>
<p>后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.c.o: foo.h</span><br><span class="line">    $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $[</span><br></pre></td></tr></table></figure>
<p>这个例子，就是说，文件”.c.o”依赖于文件”foo.h”，而不是我们想要的这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%.o: %.c foo.h</span><br><span class="line">    $(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $[</span><br></pre></td></tr></table></figure>
<p>后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。</p>
<p>而要让make知道一些特定的后缀，我们可以使用伪目标”.SUFFIXES”来定义或是删除，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.SUFFIXES: .hack .win</span><br></pre></td></tr></table></figure>
<p>把后缀.hack和.win加入后缀列表中的末尾。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.SUFFIXES:              # 删除默认的后缀</span><br><span class="line">.SUFFIXES: .c .o .h   # 定义自己的后缀</span><br></pre></td></tr></table></figure>
<p>先清楚默认后缀，后定义自己的后缀列表。</p>
<p>make的参数”-r”或”-no-builtin-rules”也会使用得默认的后缀列表为空。而变量”SUFFIXE”被用来定义默认的后缀列表，你可以用”.SUFFIXES”来改变后缀列表，但请不要改变变量”SUFFIXE”的值。</p>
<h3 id="隐含规则搜索算法"><a href="#隐含规则搜索算法" class="headerlink" title="隐含规则搜索算法"></a>隐含规则搜索算法</h3><p>比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是”archive(member)”的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把”member”当作T来搜索。</p>
<p>1、把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是”src/foo.o”，那么，D就是”src/“，N就是”foo.o”）</p>
<p>2、创建所有匹配于T或是N的模式规则列表。</p>
<p>3、如果在模式规则列表中有匹配所有文件的模式，如”%”，那么从列表中移除其它的模式。</p>
<p>4、移除列表中没有命令的规则。</p>
<p>5、对于第一个在列表中的模式规则：<br>] 推导其”茎”S，S应该是T或是N匹配于模式中”%”非空的部分。<br>] 计算依赖文件。把依赖文件中的”%”都替换成”茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。<br>] 测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫”理当存在”）<br>] 如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</p>
<p>6、如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：<br>] 如果规则是终止规则，那就忽略它，继续下一条模式规则。<br>] 计算依赖文件。（同第5步）<br>] 测试所有的依赖文件是否存在或是理当存在。<br>] 对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。<br>] 如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</p>
<p>7、如果没有隐含规则可以使用，查看”.DEFAULT”规则，如果有，采用，把”.DEFAULT”的命令给T使用。</p>
<p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</p>
<h2 id="使用make更新函数库文件"><a href="#使用make更新函数库文件" class="headerlink" title="使用make更新函数库文件"></a>使用make更新函数库文件</h2><p>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令”ar”来完成打包工作。</p>
<h3 id="函数库文件的成员"><a href="#函数库文件的成员" class="headerlink" title="函数库文件的成员"></a>函数库文件的成员</h3><p>一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">archive(member)</span><br></pre></td></tr></table></figure>
<p>这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了”ar”命令来服务的。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foolib(hack.o): hack.o</span><br><span class="line">    ar cr foolib hack.o</span><br></pre></td></tr></table></figure>
<p>如果要指定多个member，那就以空格分开，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foolib(hack.o kludge.o)</span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foolib(hack.o) foolib(kludge.o)</span><br></pre></td></tr></table></figure>
<p>你还可以使用Shell的文件通配符来定义，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foolib(*.o)</span><br></pre></td></tr></table></figure>

<h3 id="函数库成员的隐含规则"><a href="#函数库成员的隐含规则" class="headerlink" title="函数库成员的隐含规则"></a>函数库成员的隐含规则</h3><p>当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是”a(m)”形式的，其会把目标变成”(m)”。于是，如果我们的成员是”%.o”的模式定义，并且如果我们使用”make foo.a(bar.o)”的形式调用Makefile时，隐含规则会去找”bar.o”的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cc -c bar.c -o bar.o</span><br><span class="line">ar r foo.a bar.o</span><br><span class="line">rm -f bar.o</span><br></pre></td></tr></table></figure>
<p>还有一个变量要注意的是”$%”，这是专属函数库文件的自动化变量，有关其说明请参见”自动化变量”一节。</p>
<h3 id="函数库文件的后缀规则"><a href="#函数库文件的后缀规则" class="headerlink" title="函数库文件的后缀规则"></a>函数库文件的后缀规则</h3><p>你可以使用”后缀规则”和”隐含规则”来生成函数库打包文件，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.c.a:</span><br><span class="line">    $(CC) $(CFLAGS) $(CPPFLAGS) -c $[ -o $*.o</span><br><span class="line">    $(AR) r $@ $*.o</span><br><span class="line">    $(RM) $*.o</span><br></pre></td></tr></table></figure>
<p>其等效于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(%.o): %.c</span><br><span class="line">    $(CC) $(CFLAGS) $(CPPFLAGS) -c $[ -o $*.o</span><br><span class="line">    $(AR) r $@ $*.o</span><br><span class="line">    $(RM) $*.o</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在进行函数库打包文件生成时，请小心使用make的并行机制（”-j”参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。</p>
<p>但就目前而言，你还是应该不要尽量不要使用”-j”参数。</p>
<h2 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h2><p>终于到写结束语的时候了，以上基本上就是GNU make的Makefile的所有细节了。其它的产商的make基本上也就是这样的，无论什么样的make，都是以文件的依赖性为基础的，其基本是都是遵循一个标准的。这篇文档中80%的技术细节都适用于任何的make，我猜测”函数”那一章的内容可能不是其它make所支持的，而隐含规则方面，我想不同的make会有不同的实现，我没有精力来查看GNU的make和VC的nmake、BCB的make，或是别的UNIX下的make有些什么样的差别，一是时间精力不够，二是因为我基本上都是在Unix下使用make，以前在SCO Unix和IBM的AIX，现在在Linux、Solaris、HP-UX、AIX和Alpha下使用，Linux和Solaris下更多一点。不过，我可以肯定的是，在Unix下的make，无论是哪种平台，几乎都使用了Richard Stallman开发的make和cc/gcc的编译器，而且，基本上都是GNU的make（公司里所有的UNIX机器上都被装上了GNU的东西，所以，使用GNU的程序也就多了一些）。GNU的东西还是很不错的，特别是使用得深了以后，越来越觉得GNU的软件的强大，也越来越觉得GNU的在操作系统中（主要是Unix，甚至Windows）”杀伤力”。</p>
<p>对于上述所有的make的细节，我们不但可以利用make这个工具来编译我们的程序，还可以利用make来完成其它的工作，因为规则中的命令可以是任何Shell之下的命令，所以，在Unix下，你不一定只是使用程序语言的编译器，你还可以在Makefile中书写其它的命令，如：tar、awk、mail、sed、cvs、compress、ls、rm、yacc、rpm、ftp……等等，等等，来完成诸如”程序打包”、”程序备份”、”制作程序安装包”、”提交代码”、”使用程序模板”、”合并文件”等等五花八门的功能，文件操作，文件管理，编程开发设计，或是其它一些异想天开的东西。比如，以前在书写银行交易程序时，由于银行的交易程序基本一样，就见到有人书写了一些交易的通用程序模板，在该模板中把一些网络通讯、数据库操作的、业务操作共性的东西写在一个文件中，在这些文件中用些诸如”@@@N、###N”奇怪字串标注一些位置，然后书写交易时，只需按照一种特定的规则书写特定的处理，最后在make时，使用awk和sed，把模板中的”@@@N、###N”等字串替代成特定的程序，形成C文件，然后再编译。这个动作很像数据库的”扩展C”语言（即在C语言中用”EXEC　SQL”的样子执行SQL语句，在用cc/gcc编译之前，需要使用”扩展C”的翻译程序，如cpre，把其翻译成标准C）。如果你在使用make时有一些更为绝妙的方法，请记得告诉我啊。</p>
<p>回头看看整篇文档，不觉记起几年前刚刚开始在Unix下做开发的时候，有人问我会不会写Makefile时，我两眼发直，根本不知道在说什么。一开始看到别人在vi中写完程序后输入”!make”时，还以为是vi的功能，后来才知道有一个Makefile在作怪，于是上网查啊查，那时又不愿意看英文，发现就根本没有中文的文档介绍Makefile，只得看别人写的Makefile，自己瞎碰瞎搞才积累了一点知识，但在很多地方完全是知其然不知所以然。后来开始从事UNIX下产品软件的开发，看到一个400人年，近200万行代码的大工程，发现要编译这样一个庞然大物，如果没有Makefile，那会是多么恐怖的一样事啊。于是横下心来，狠命地读了一堆英文文档，才觉得对其掌握了。但发现目前网上对Makefile介绍的文章还是少得那么的可怜，所以想写这样一篇文章，共享给大家，希望能对各位有所帮助。</p>
<p>现在我终于写完了，看了看文件的创建时间，这篇技术文档也写了两个多月了。发现，自己知道是一回事，要写下来，跟别人讲述又是另外一回事，而且，现在越来越没有时间专研技术细节，所以在写作时，发现在阐述一些细节问题时很难做到严谨和精练，而且对先讲什么后讲什么不是很清楚，所以，还是参考了一些国外站点上的资料和题纲，以及一些技术书籍的语言风格，才得以完成。整篇文档的提纲是基于GNU的Makefile技术手册的提纲来书写的，并结合了自己的工作经验，以及自己的学习历程。因为从来没有写过这么长，这么细的文档，所以一定会有很多地方存在表达问题，语言歧义或是错误。因些，我迫切地得等待各位给我指证和建议，以及任何的反馈。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>转载自<a href="http://blog.csdn.net/haoel/article/details/2886" target="_blank" rel="noopener">陈皓的Blog</a></p>
]]></content>
      <categories>
        <category>编程笔记</category>
      </categories>
  </entry>
</search>
